# python script to convert the list of determinants generated by OpenMolcas 
# into a format that can be processed by GronOR, to be used until this
# functionality is integrated in GronOR. 
# execute by: python civec.py argument1 argument2
# argument1 is the number of sets of CI coefficients (number of states)
# argument2 is the project name used to generate the names of the civ files.
#
# The script removes the duplicates in the list of determinants that 
# appear when a list of CSFs is translated into a list of determinants. 
# It also generates a histogram of the number of determinants with
# coefficients in a certain interval: c_i > 0.1; 0.1 > c_i > 0.01; etc.

import sys


def partition(array,begin,end):
	pivot = begin
	for i in range(begin + 1, end + 1):
		if array[i] <= array[begin]:
			pivot +=1
			array[i],array[pivot] = array[pivot],array[i]
	array[pivot], array[begin] = array[begin], array[pivot]
	return pivot

def quicksort(array, begin = 0, end = None):
	if end == None:
		end = len(array) - 1
	def _quicksort(array, begin, end):
		if begin >= end:
			return
		pivot = partition(array,begin,end)
		_quicksort(array, begin, pivot - 1)
		_quicksort(array, pivot + 1 , end)
	return _quicksort(array, begin, end)


def read_vecdet(filename,inact,array):
# read the determinant labels and the CI coefficients from the molcas vecdet file
# we keep them as one string for easier sorting. For sorting on the label, the 
# coefficient and the label are changed of place
	with open(filename,"r") as fin:
	        a = fin.readline()
	        l = a.split()
	        for i in range(0,len(l)):
			inact.append(int(l[i]))
		for line in fin:
			a = line.split()
			array.append(a[1]+'  '+a[0])
	fin.close

def separate(array,coeff,label):
# store the determinant label and its CI coefficient in separate lists
	for i in range(0,len(array)):
		a = array[i].split()
		label.append(a[0])
		coeff.append(float(a[1]))

def calculate_norm(a):
# calculate the deviation from 1 of the norm of the CI vector (for checking purposes only)
	norm = 0.0
	for i in range(0,len(a)):
		norm += a[i]*a[i]
	deviation = 1.0 - norm
        return deviation
        
	
def eliminate_duplicates(aa,a,bb,b):
# eliminate the duplicate determinant labels and sum their CI coefficients
# relies on a list sorted by the labels
	counter = 0
        aa.append('end_of_list')
	while aa[counter] != 'end_of_list':
		if aa[counter] != aa[counter+1]:
			a.append(label[counter])
			b.append(coeff[counter])
		else:
			bb[counter] += bb[counter+1]
	                bb[counter+1] = bb[counter]
		counter += 1
	aa.pop()

def adopt_labels(a):
# change the determinant labels to GronOR format (actually Gamess format)
	for i in range(0,len(a)):
	        k = []
	        l = list(a[i])
	        for j in range(0,len(l)):
	                if l[j] == '2':
	                        k.append('11 ')
	                if l[j] == 'a':
	                        k.append('10 ')
	                if l[j] == 'b':
	                        k.append('01 ')
	                if l[j] == '0':
	                        k.append('00 ')
	        a[i] = ''.join(k)

def calculate_distribution(a,freq):
	for i in range(0,len(a)):
	        abs_a = abs(a[i])
	        if abs_a > 1e-1:
	                freq[0] += 1
	        elif abs_a > 1e-2:
	                freq[1] += 1
	        elif abs_a > 1e-3:
	                freq[2] += 1
	        elif abs_a > 1e-4:
	                freq[3] += 1
	        elif abs_a > 1e-5:
	                freq[4] += 1
	        elif abs_a > 1e-6:
	                freq[5] += 1
	        elif abs_a > 1e-7:
	                freq[6] += 1
	        elif abs_a > 1e-8:
	                freq[7] += 1
	        elif abs_a > 1e-9:
	                freq[8] += 1
	        elif abs_a > 1e-10:
	                freq[9] += 1
	        elif abs_a > 1e-11:
	                freq[10] += 1
	        elif abs_a > 1e-12:
	                freq[11] += 1

def permute(a,c):
# calculate the number of permutations to obtain the desired alpha-beta ordering
# for determinants with ms not equal to zero, excess alphas are moved to the end
	for i in range(0,len(a)):
		numberOfPermutations = 0
		shortDet = eliminate_empty(a[i])
		ms = alpha_minus_beta(shortDet)
                if ms != 0:
			shortDet,numberOfPermutations = put_alphas_at_the_end(shortDet,ms)
		for j in range(0,len(shortDet) - 1 - ms ):
			position1 = j % 2
			if shortDet[j] == 'a':
				spin = 0
			else:
				spin = 1
			if position1 != spin:
				oppositeSpin = abs(spin - 1)
                                permutation = False
                                k = j
                                while ( not permutation ):
                                        k += 1
					if shortDet[j] != shortDet[k]:
						position2 = k % 2
						if position2 != oppositeSpin:
							aux = shortDet[j]
							shortDet[j] = shortDet[k]
							shortDet[k] = aux
							permutation = True
							numberOfPermutations += k - j
		if numberOfPermutations % 2 == 1:
			c[i] = -c[i]

def eliminate_empty(det):
# eliminate the empty orbitals and explicitly write 'a b' for the doubly occupied
	l = list(det)
        short = []
        for i in range(0,len(l)):
		if l[i] == '2':
			short.append('a')
			short.append('b')
		if l[i] == 'a' or l[i] == 'b':
			short.append(l[i])
        return short

def alpha_minus_beta(det):
# determine the ms of the determinant
	l = list(det)
	ms = 0
	for i in range(0,len(l)):
		if l[i] == 'a':
			ms += 1
		if l[i] == 'b':
			ms -= 1
	return ms

def put_alphas_at_the_end(det,ms):
# In case the determinant has ms > 0, 'excess' alphas are moved to the end
	l = list(det)
        permutations = 0
	for i in range(len(l)-ms,len(l)):
		if l[i] == 'b':
                        j = 0
			permutation = False
                        while ( not permutation ):
				if l[j] == 'a':
					l[j] = 'b'
					l[i] = 'a'
					permutations += i - j
					permutation = True
				j += 1
	det = l
        return det,permutations
        

### end of functions ###


numberOfStates = int(sys.argv[1])
project = sys.argv[2]

print "State      number of dets              frequency of CI coefficients larger than"
print "           raw      unique           0.1   1e-2   1e-3   1e-4   1e-5   1e-6   1e-7   1e-8   1e-9   1e-10  1e-11  1e-12" 
for iState in range(1,numberOfStates+1):
	array = []
	inact = []
	filename = 'vecdet.' + str(iState)
	read_vecdet(filename,inact,array)
	quicksort(array)

	label = []
	coeff = []
        separate(array,coeff,label)
	deviation = calculate_norm(coeff)
        if abs(deviation) > 1e-6:
		print "Warning, large deviation from 1 in the norm of the original array of CI coefficients: %10.2e" % deviation

	labelUnique = []
	coeffUnique = []
        eliminate_duplicates(label,labelUnique,coeff,coeffUnique)
	deviation = calculate_norm(coeffUnique)
        if abs(deviation) > 1e-6:
		print "Warning, large deviation from 1 in the norm of the list of unique determinants: %10.2e" % deviation
        permute(labelUnique,coeffUnique)
        adopt_labels(labelUnique)
	filename = project + '_' + str(iState).zfill(3) + '.civ'
	outfile = open(filename,'w')
	outfile.write("%4d  %4d   %4d\n" % (len(labelUnique),int(len(list(labelUnique[0]))/3),sum(inact)))
	for i in range(0,len(labelUnique)):
	        outfile.write( " %6d %24.14f      %s\n" % (i+1,coeffUnique[i],labelUnique[i]))

	freq = [0 for i in range(0,12)]
	calculate_distribution(coeffUnique,freq)
        fmt = "  " + '      '.join(["{:3d}"]*3) + "        " + ''.join(["{:7d}"]*len(freq))
	print(fmt.format(iState, len(label), len(labelUnique), *freq))



