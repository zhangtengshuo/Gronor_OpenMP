      program read_traint
* Experimental code for writing the integrals in the common MO basis 
* generated by OpenMolcas in a format that can be processed by GronOR.
* The Project.sym file only contains some general info on coordinates
* basic basis set info. Symmetry should be stripped off from GronOR.
*
* project is taken from the command line as argument to rdtraint
*  > rdtraint project
*
* 5 files from OpenMolcas are needed:
*   ONEINT        AO overlap matrix of the system
*   RUNFILE       General info
*   COMMONORB     Common MO basis in OpenMolcas format 
*   TRAONE        Transformed 1-el. integrals
*   TRAINT        Transformed 2-el. integrals
*
* For some funny reason that escapes me, MOLCAS_MEM needs to defined
*   > export MOLCAS_MEM=1000 (or any other number you like)
*

      implicit none


      integer, parameter                :: nToc = 64
      integer, parameter                :: nTraToc = 106,nTraBuf = 9600
      integer, parameter                :: mxSym = 8, maxBfn = 10000
      integer, parameter                :: labelSize = 2 * maxBfn * 4
      integer, parameter                :: LblL  = 6           !LenIN  in OpenMolcas
      integer, parameter                :: LblL8 = lblL + 8    !LenIN8 in OpenMolcas
      integer                           :: luTra, luOne, iAd30, iAd50
      integer                           :: luOne_GronOR,luTwo_GronOR
      integer                           :: iSym, nSym, nOrbtt
      integer                           :: i,j,k,l,m,nt,ltuvx,ii,jj,n
      integer                           :: nonZeroInt
      integer                           :: iCounter,non_zero
      integer                           :: ii_start,jj_start
      integer                           :: iBuf,nBuf,lastBuf,ilast,nrec
      integer                           :: recordNumber,recordLength
      integer                           :: lTriangle,nBasMax
      integer                           :: iRC,iOpt,iComponent,iSymlbl
      integer                           :: nBasTot,nOrbTot,iAtom,nAtoms
      integer (kind=2), dimension(4*nTraBuf) :: labels

      integer (kind=2), dimension(4*nTraBuf) :: intlabels

      integer, dimension(mxSym)         :: nBas, nOrb, nDMO,
     &                                     nDouble, nActive,nOcc,
     &                                     nFrozen
      integer, allocatable              :: nCntr(:,:)
      integer, allocatable              :: kl(:,:)
      integer, dimension(nToc)          :: iToc
      integer, dimension(nTraToc)       :: iTraToc
      real (kind=8)                     :: potNuc,scal,almostZero,
     &                                     percentage
      real (kind=8), dimension(nTraBuf) :: traBuf

      real (kind=8), dimension(nTraBuf) :: integrals

      real (kind=8), allocatable        :: s(:),sAO(:,:,:)
      real (kind=8), allocatable        :: vec(:,:,:)
      real (kind=8), allocatable        :: kinInt(:)
      real (kind=8), allocatable        :: fock(:)
      real (kind=8), allocatable        :: zero(:)
      real (kind=8), allocatable        :: dummy(:)
      real (kind=8), allocatable        :: coord(:),znuc(:)
      character (len = 1), dimension(labelSize) :: basLabel
      character (len = LblL), allocatable   :: AtomLbl(:)
      character (len = LblL8), allocatable  :: BasfnLbl(:)
      character (len = 5)               :: mark
      character (len = 19)              :: lAO
      character (len = 80)              :: title1,title2
      character (len = 80)              :: Project,filename
      character (len = 132)             :: line,vectit
      character (len = 144)             :: Header
      logical                           :: debug,empty,deep_debug

      debug = .false.
      deep_debug = .false.
      call get_command_argument(1,Project) 
* open the ONEINT file to access the AO overlap matrix (needed to calculate sMO)
      nBas = 0
      call NameRun('RUNFILE')              ! ONEINT cannot be accessed without RUNFILE
      call Get_iScalar('nSym',nSym)
      if ( nSym .ne. 1 ) then
        write(*,*) '  Symmetry is not implemented in GronOR'
        write(*,*) 'Remove the symmetry elements and come back'
        stop
      end if
      Call Get_iArray('nBas',nBas,nSym)
      write(*,'(A,8I4)')'nBas    :',(nBas(iSym),iSym=1,nSym)
      nBasTot = 0                          ! total number of AO basis functions
      do iSym = 1, nSym
        nBasTot = nBasTot + nBas(iSym)
      end do
      nBasMAx = maxval(nBas)
      lTriangle = 0.5 * nBasTot * (nBasTot + 1)
      allocate ( s(lTriangle) )
      allocate ( sAO(nSym,nBasMax,nBasMax) )
      s   = 0.0
      sAO = 0.0
      LuOne = 77
      iRc=-1
      iOpt=0
      Call OpnOne(iRC,iOpt,'ONEINT',LuOne)
      if (iRC.ne.0) write(6,*) 'Something went wrong opening ONEINT'
      iRC =  0
      iOpt = 2
      iComponent = 1
      iSymLbl = 1
      Call RdOne(iRC,iOpt,'Mltpl  0',iComponent,s,iSymLbl)
      Call ClsOne(iRc,iOpt)
      iCounter = 1
      do iSym = 1, nSym
        do j = 1, nBas(iSym)
          do k = 1, j
            sAO(iSym,j,k) = s(iCounter)
            sAO(iSym,k,j) = s(iCounter)
            iCounter = iCounter + 1
          end do
        end do
      end do
      if ( deep_debug ) then
        write (*,*) 'AO basis overlap'
        do iSym = 1, nSym
          do j = 1, nBas(iSym)
            write(*,'(20F10.4)')(sAO(iSym,j,k),k = 1, j)
          end do
        end do
      end if
      s = 0.0
      iCounter = 0                                        ! reset s and iCounter; s will be re-used for the MO overlap


* open the file with the one-electron integrals (TRAONE)
      luOne = 30
      call DANAME(luOne,'TRAONE')

* read info from TRAONE
      iAd30 = 0
      call WR_MOTRA_Info(luOne,2,iAd30,
     &                   iToc, nToc, potNuc,nSym, nBas, nOrb,
     &                   nFrozen, nDMO, mxSym, basLabel, labelSize)

      write(*,*)'Info from TRAONE'
      write(*,'(A,8I4)')'nBas    :',(nBas   (iSym),iSym=1,nSym)
      write(*,'(A,8I4)')'nFrozen :',(nFrozen(iSym),iSym=1,nSym)
      write(*,'(A,8I4)')'nOrb    :',(nOrb   (iSym),iSym=1,nSym)
      write(*,'(A,8I4)')'nDeleted:',(nDMO   (iSym),iSym=1,nSym)
      nOrbTot = 0                          ! number of basis functions in the common MO basis
      nOrbtt = 0                           ! number of elements in the  lower triangle
      nBasTot = 0                          ! total number of AO basis functions
      do iSym = 1, nSym
        nOrbtt = nOrbtt + (nOrb(iSym) * (nOrb(iSym) + 1)) / 2
        nOrbTot = nOrbTot + nOrb(iSym)
        nBasTot = nBasTot + nBas(iSym)
      end do
      nBasMAx = maxval(nBas)
      lTriangle = 0.5 * nBasTot * (nBasTot + 1)


* open the file with the molecular orbitals and calculate sMO (not necessarily a unit matrix with NOCI)
      allocate( dummy(nBasMax) )
      open(11, file = 'COMMONORB', status = 'old')
      mark ='#INFO'
 63   read(11,'(A132)') line
      if (line(1:5).ne.mark) goto 63
      read(11,'(A132)') vectit
      write(*,*)
      write(*,*) vectit
      rewind(11)
      allocate ( vec(nSym,nOrbTot,nBasMax) )
      vec = 0.0
      mark = '#ORB'
 64   read(11,'(A132)') line
      if (line(1:4).ne.mark) goto 64
      do iSym = 1, nSym
        if (nBas(iSym) .ne. 0) then
          do j = 1, nFrozen(iSym)                          ! Skip the frozen orbitals, if any
            read(11,'(A132)') line
            read(11,'(5E22.14)') (dummy(k),k=1,nBas(iSym))
          end do
          do j = 1, nOrb(iSym)                             ! Only read the occupied (inactive + active) orbitals
            read(11,'(A132)') line
            read(11,'(5E22.14)') (vec(iSym,j,k),k=1,nBas(iSym))
          end do
        end if
        write(*,202) 'Start overlap MOs for ',nOrb(iSym),' orbitals'
 202    format(A,I6,A)
        do j = 1, nOrb(iSym)
          do k = 1, j
            iCounter = iCounter + 1
            do l = 1, nBas(iSym)
              do m = 1, nBas(iSym)
                s(iCounter) = s(iCounter) + vec(iSym,j,l) 
     &                         * vec(iSym,k,m) * sAO(iSym,l,m)
              end do
            end do
            if ( debug ) write(*,*) iCounter,s(iCounter)
            if ( mod(iCounter,int(nOrbtt/10)) .eq. 0 ) then
              write(*,'(I3,A)') 100*(iCounter)/nOrbtt,'% done'
            end if
          end do
        end do
      end do 
      deallocate(dummy)
      write(*,*) 

* allocate memory and read one-electron integrals
      allocate ( fock(nOrbtt) )
      allocate ( kinInt(nOrbtt) )
      allocate ( zero(nOrbtt) )
      zero = 0.0
      iAd30 = iToc(2)
      call dDAFILE(luOne,2,fock,nOrbtt,iAd30)
      iAd30 = iToc(3)
      call dDAFILE(luOne,2,kinInt,nOrbtt,iAd30)

      if (debug) then
        write(*,*) 'S, V and T'
        do i = 1, nOrbtt
          write(*,'(i4,3F14.8)') i, s(i),fock(i),kinInt(i)
        end do
      endif

* Dump the one-electron integrals in 'filone'
      if (vectit(40:45).eq.'tau_MO') then
        title1 = 'Integrals in common MO basis ('
     &                       //vectit(40:57)//')'
      else
        title1 = 'Integrals in '//vectit(3:132)
      endif
      title2 = 'from openMolcas to GronOr by rdtraint '
      write(*,*) title1
      write(*,*) title2
      write(*,*)
      luOne_GronOR = 31
      write(filename,'(2a)')trim(Project),'.one'
      open(luOne_GronOR, file = filename, form = 'unformatted')
      write(luOne_GronOR) title1,title2,nOrbtt,potNuc,nOrbTot,nTraBuf,0
      write(luOne_GronOR) (s(i),i=1,nOrbtt)
*      write(luOne_GronOR) (fock(i),i=1,nOrbtt)
*      write(luOne_GronOR) (fock(i)-kinInt(i),i=1,nOrbtt)
      write(luOne_GronOR) (zero(i),i=1,nOrbtt)
      write(luOne_GronOR) (fock(i),i=1,nOrbtt)
      write(luOne_GronOR) (/8421,-1,1/)     !no idea what this is

* open the file with the two-electron integrals (TRAINT)
      luTra = 50
      call DANAME_MF(lutra,'TRAINT')

* read table of contents of TRAINT
      iAd50 = 0
      call iDAFILE(luTra,2,iTraToc,nTraToc,iad50)

* calculate number of two-electron integrals, ltuvx
      ltuvx = 0
      do iSym = 1, nSym
        nt = (nOrb(isym) * (nOrb(iSym) + 1)) / 2
        do i = 1, nOrb(iSym)
          do j = 1, i
            do k = 1, nt
              ltuvx = ltuvx + 1
            end do
            nt = nt - 1
          end do
        end do
      end do
      nBuf = int(ltuvx/nTraBuf)
      lastBuf = ltuvx - nBuf * nTraBuf
      write(*,*) 'Number of 2 el. integrals :',ltuvx
      write(*,*) 'Number of full buffers    :',nBuf
      write(*,*) 'Length of last buffer     :',lastBuf
* some additional info on the 2-el ints is expected on luOne_GronOR
      write(luOne_GronOR) ltuvx     !  number of integrals
      write(luOne_GronOR) 1         !  number of files with two-el. integrals
      if (lastBuf .eq. 0) then
        write(luOne_GronOR) nBuf 
        write(luOne_GronOR) nBuf * nTraBuf
      else
        write(luOne_GronOR) nBuf + 1
        write(luOne_GronOR) (nBuf + 1) * nTraBuf
      end if
      close(luOne_Gronor)

* set up a small array for generating the labels i, j, k and l label of the 2-el integrals
      allocate( kl(nOrbtt,2) )
      kl = 0
      iCounter = 0
      do l=1,nOrbtot
        do k = 1, l
          iCounter = iCounter + 1
          kl(iCounter,1) = k
          kl(iCounter,2) = l
        end do
      end do
      if ( debug ) then
        write(*,*) 'lower triangle of the k-l labels'
        do l = 1, nOrbtt
          write(*,*) l,kl(l,1),kl(l,2)
        end do
      end if

* read the two-electron integrals in nBuf batches of nTraBuf length
      luTwo_GronOR = 32
      inquire( iolength = nrec ) traBuf(1)
      RecordLength = ( 2 * ntraBuf + 2 ) * nrec
      if ( debug ) write(*,*)'nrec and Record length:',nrec,recordLength
      write(filename,'(2a)')trim(Project),'_001.two'
      open(luTwo_GronOR, file = filename, form = 'unformatted', 
     &                   access = 'direct', recl = RecordLength)
      iCounter = 0
      ii_start = 1
      jj_start = 1
      ilast = 0
      almostZero = 1e-6
      nonZeroInt = 0
      recordNumber = 0
      do iBuf = 1, nBuf
        recordNumber = recordNumber + 1
        if (iBuf .eq. nBuf .and. lastBuf .eq. 0) ilast = 1      ! in the very special case that the number of ints is a multiple of nTraBuf
        call dDAFILE(luTra,2,traBuf,nTraBuf,iad50)
        do n = 1, nTraBuf
          if ( abs(traBuf(n)) .lt. almostZero ) nonZeroInt=nonZeroInt+1
        end do
        do ii = ii_start, nOrbtt
          do jj = jj_start, nOrbtt
            iCounter = iCounter + 1
            if (iCounter .le. nTraBuf) then
              i = kl(ii,1)
              j = kl(ii,2)
              k = kl(jj,1)
              l = kl(jj,2)
              labels((iCounter-1)*4+1) = i
              labels((iCounter-1)*4+2) = j
              labels((iCounter-1)*4+3) = k
              labels((iCounter-1)*4+4) = l
              traBuf(iCounter) = traBuf(iCounter)*scal(i,j,k,l)
              if ( deep_debug ) write(*,'(5i4,F8.3,F12.6)')
     &           iCounter,i,j,k,l,scal(i,j,k,l),traBuf(iCounter)
              if (( debug ) .and. ( iBuf .eq. 1 ) .and. ( iCounter .le.
     &            10 )) write(*,'(4I4,F18.12)') i,j,k,l,traBuf(iCounter)
            else    
              goto 59
            end if
          end do
          jj_start = ii + 1
        end do
 59     ii_start = ii
        jj_start = jj 
        iCounter = 0
        write(luTwo_GronOR,rec=recordNumber) (traBuf(n),n=1,nTraBuf),   ! Dump the 2-el. ints on the GronOR file
     &                      (labels(n),n=1,4*nTraBuf),nTraBuf,ilast
      end do
* one last read with the remaining lastBuf integrals
      if ( lastBuf .gt. 0 ) then
        traBuf = 0.0
        labels = 0
        recordNumber = recordNumber + 1
        call dDAFILE(luTra,2,traBuf,lastBuf,iad50)
        do n = 1, lastBuf
          if ( abs(traBuf(n)) .lt. almostZero ) nonZeroInt=nonZeroInt+1
        end do
        do ii = ii_start, nOrbtt
          do jj = jj_start, nOrbtt
            iCounter = iCounter + 1
            if (iCounter .le. lastBuf) then
              i = kl(ii,1)
              j = kl(ii,2)
              k = kl(jj,1)
              l = kl(jj,2)
              labels((iCounter-1)*4+1) = i
              labels((iCounter-1)*4+2) = j
              labels((iCounter-1)*4+3) = k
              labels((iCounter-1)*4+4) = l
              traBuf(iCounter) = traBuf(iCounter)*scal(i,j,k,l)
              if ( deep_debug ) write(*,'(5i4,F8.3,F20.10)')
     &           iCounter,i,j,k,l,scal(i,j,k,l),traBuf(iCounter)
            end if
          end do
          jj_start = ii + 1
        end do
        write(luTwo_GronOR,rec=recordNumber) (traBuf(n),n=1,nTraBuf),   ! Dump the last 2-el. ints on the GronOR file
     &        (labels(n),n=1,4*nTraBuf),lastBuf,1

      end if
      close(luTwo_GronOR)
      write(*,'(A,ES8.1,A,I8)')'Number of integrals smaller than ',
     &                                    almostZero, ' :  ',nonZeroInt
      percentage = 100*(float(nonZeroInt)/float(ltuvx))
      if ( percentage .ge. 1e-2) then
        write(*,'(A,F6.2,A)') '( ',percentage,' % of the total)'
      else
        write(*,'(A,F6.2,A)') '(less than ',1e-2,' % of the total)'
      end if
* close the files
      call DACLOS(luOne)
      call DACLOS(luTra)

* deallocate
      deallocate (sAO)
      deallocate (vec)
      deallocate (s)
      deallocate (fock)
      deallocate (kinInt)


* fill the sym file with info
      write(filename,'(2a)')trim(Project),'.sym'
      open(15,file=trim(filename))
      write(15,'(A)') ' * * * General info from OpenMolcas to GronOR'
      Call Get_cArray('Seward Title',Header,144)
      empty = .true.
      do i = 1, 72
        if (Header(i:i) .ne. ' ' ) empty = .false.
      end do
      if ( empty ) Header(1:28) = ' (No title provided by user)'
      write(15,'(A)') Header(1:72)
      write(15,'(A)') Header(73:144)
      Call Get_nAtoms_All(nAtoms)
      write(15,'(A,I4)') 'number of atoms: ',nAtoms
      allocate( coord(3 * nAtoms) )
      allocate( AtomLbl(nAtoms) )
      allocate( BasfnLbl(nBasTot) )                              ! see comment 1
      allocate( zNuc(nAtoms) )
      allocate( nCntr(nAtoms,7) )
      Call Get_Coord_All(coord,nAtoms)
      Call Get_cArray('Unique Atom Names',AtomLbl,LblL*nAtoms)
      Call Get_cArray('Unique Basis Name',BasfnLbl,nBasTot*LblL8)
      Call Get_dArray('Nuclear charge',zNuc,nAtoms)
      nCntr = 0
      iAtom = 1
      if (BasfnLbl(1)(9:9).eq.'s') nCntr(1,1)=1
      if (BasfnLbl(1)(9:9).eq.'p') nCntr(1,2)=1
      if (BasfnLbl(1)(9:9).eq.'d') nCntr(1,3)=1
      if (BasfnLbl(1)(9:9).eq.'f') nCntr(1,4)=1
      if (BasfnLbl(1)(9:9).eq.'g') nCntr(1,5)=1
      if (BasfnLbl(1)(9:9).eq.'h') nCntr(1,6)=1
      if (BasfnLbl(1)(9:9).eq.'i') nCntr(1,7)=1
      do j = 2, nBasTot
        if ( BasfnLbl(j)(1:6) .ne. BasfnLbl(j-1)(1:6) ) 
     &                                  iAtom = iAtom + 1   ! next atom
        if (BasfnLbl(j)(9:9).eq.'s') nCntr(iAtom,1)=nCntr(iAtom,1)+1
        if (BasfnLbl(j)(9:9).eq.'p') nCntr(iAtom,2)=nCntr(iAtom,2)+1
        if (BasfnLbl(j)(9:9).eq.'d') nCntr(iAtom,3)=nCntr(iAtom,3)+1
        if (BasfnLbl(j)(9:9).eq.'f') nCntr(iAtom,4)=nCntr(iAtom,4)+1
        if (BasfnLbl(j)(9:9).eq.'g') nCntr(iAtom,5)=nCntr(iAtom,5)+1
        if (BasfnLbl(j)(9:9).eq.'h') nCntr(iAtom,6)=nCntr(iAtom,6)+1
        if (BasfnLbl(j)(9:9).eq.'i') nCntr(iAtom,7)=nCntr(iAtom,7)+1
      end do
      iCounter = 1
      lAO = 's  p  d  f  g  h  i'
      write(15,'(6x,A,10x,2A,5x,A)')
     & 'Atom','x             y             z',
     &         '          Znuc',lAO
      do iAtom = 1, nAtoms
        write(15,201)iAtom,AtomLbl(iAtom),(coord(k),k=iCounter,
     &         iCounter+2),zNuc(iAtom),(nCntr(iAtom,l)/(2*(l-1)+1),
     &         l=1,7)
        iCounter = iCounter + 3
      end do
 201  format (I4,2x,A6,3F14.8,2x,F7.2,3x,7I3)
      end

      function scal(i,j,k,l)
      integer   :: i,j,k,l
      real (kind = 8)      :: scal
      scal = 1.0
      if ( i .eq. j ) scal = scal * 0.5
      if ( k .eq. l ) scal = scal * 0.5
      if ( ( i. eq. k .and. j .eq. l )
     &     .or.
     &   ( i .eq. l .and. j .eq. k ) ) scal = scal * 0.5
      return 
      end 

! Comment 1: The number of s, p, d etc. functions per atom is not known outside Molcas, this info is not
! written to any file (ONEINT, RUNFILE, TRAINT, JOBIPH). Therefore we have to determine it in an indirect
! way by comparing the basis set labels. If this interface is integrated in Molcas, the info is directly
! available through common blocks.


