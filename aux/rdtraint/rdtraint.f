      module input_rdtraint_data
      implicit none

      character(len=2),allocatable :: fragLabels(:,:)
      character(len=80)   :: Project
      logical             :: write_labels,write_fragIDs
      integer             :: nTraRec,print_level,nFragments
      integer,allocatable :: nVec(:)
      real(kind=8)        :: almostZero

      end module input_rdtraint_data
      
      
      program read_traint
* Experimental code for writing the integrals in the common MO basis 
* generated by OpenMolcas in a format that can be processed by GronOR.
* The Project.sym file contains some general info on coordinates
* basic basis set info and labels for the fragment functions (if provided
* in the input).
*
* 5 files from OpenMolcas are needed:
*   ONEINT        AO overlap matrix of the system
*   RUNFILE       General info
*   COMMONORB     Common MO basis in OpenMolcas format 
*   TRAONE        Transformed 1-el. integrals
*   TRAINT        Transformed 2-el. integrals
*
* For some funny reason that escapes me, MOLCAS_MEM needs to defined
*   > export MOLCAS_MEM=1000 (or any other number you like)
*

      use input_rdtraint_data
      implicit none

      integer, parameter                :: nToc = 64
      integer, parameter                :: nTraToc = 106
      integer, parameter                :: mxSym = 1, maxBfn = 10000
      integer, parameter                :: labelSize = 2 * maxBfn * 4
      integer, parameter                :: LblL  = 6           !LenIN  in OpenMolcas
      integer, parameter                :: LblL8 = lblL + 8    !LenIN8 in OpenMolcas
      integer, parameter                :: nTraBuf = 9600
      integer                           :: luTra, luOne, iAd30, iAd50
      integer                           :: luOne_GronOR,luTwo_GronOR
      integer                           :: iSym, nSym, nOrbtt
      integer                           :: i,j,k,l,m,nt,ltuvx,ii,jj,n
      integer                           :: nonZeroInt
      integer                           :: iCounter,non_zero
      integer                           :: ii_start,jj_start
      integer                           :: iBuf,nBuf,lastBuf,ilast,nrec
      integer                           :: recordNumber,recordLength
      integer                           :: recNumber2
      integer                           :: lTriangle
      integer                           :: iRC,iOpt,iComponent,iSymlbl
      integer                           :: iAtom,nAtoms
      integer (kind=2), dimension(4*nTraBuf) :: labels

      integer                           :: nBas, nOrb, nDMO,
     &                                     nDouble, nActive,nOcc,
     &                                     nFrozen
      integer, allocatable              :: nCntr(:,:),nVec(:)
      integer, allocatable              :: kl(:,:)
      integer, dimension(nToc)          :: iToc
      integer, dimension(nTraToc)       :: iTraToc
      real (kind=8)                     :: potNuc,scal,
     &                                     percentage,b,totCharge
      real (kind=8), dimension(nTraBuf) :: traBuf

      real (kind=8), dimension(nTraBuf) :: integrals

      real (kind=8), allocatable        :: s(:),sAO(:,:),aux(:,:)
      real (kind=8), allocatable        :: vec(:,:)
      real (kind=8), allocatable        :: kinInt(:)
      real (kind=8), allocatable        :: fock(:)
      real (kind=8), allocatable        :: zero(:)
      real (kind=8), allocatable        :: dummy(:)
      real (kind=8), allocatable        :: coord(:),znuc(:)
      character (len = 1), dimension(labelSize) :: basLabel
      character (len = LblL), allocatable   :: AtomLbl(:)
      character (len = LblL8), allocatable  :: BasfnLbl(:)
      character (len = 5)               :: mark
      character (len = 19)              :: lAO
      character (len = 80)              :: title1,title2
      character (len = 80)              :: filename
      character (len = 80), allocatable   :: filename_two_el(:)
      character (len = 132)             :: line,vectit
      character (len = 144)             :: Header
      logical                           :: empty

      integer, allocatable :: nRecs_onFile(:)
      integer, allocatable :: nInts_onFile(:)
      integer              :: nFiles,iFile
      integer              :: onlastrecord,nlastrecords,totRecords
      integer              :: iRec,nInts,onLastFile,stat

      call read_input

* open the ONEINT file to access the AO overlap matrix (needed to calculate sMO)
      nBas = 0
      call NameRun('RUNFILE')              ! ONEINT cannot be accessed without RUNFILE
      call Get_iScalar('nSym',nSym)
      if ( nSym .ne. 1 ) then
        write(*,*) '  Symmetry is not implemented in GronOR'
        write(*,*) 'Remove the symmetry elements and come back'
        stop
      end if
      call Get_iArray('nBas',nBas,nSym)
      lTriangle = 0.5 * nBas * (nBas + 1)
      allocate ( s(lTriangle) )
      allocate ( sAO(nBas,nBas) )
      s   = 0.0
      sAO = 0.0
      LuOne = 77
      iRc=-1
      iOpt=0
      call OpnOne(iRC,iOpt,'ONEINT',LuOne)
      if (iRC.ne.0) write(6,*) 'Something went wrong opening ONEINT'
      iRC =  0
      iOpt = 2
      iComponent = 1
      iSymLbl = 1
      call RdOne(iRC,iOpt,'Mltpl  0',iComponent,s,iSymLbl)
      call ClsOne(iRc,iOpt)
      iCounter = 1
      do j = 1, nBas
        do k = 1, j
          sAO(j,k) = s(iCounter)
          sAO(k,j) = s(iCounter)
          iCounter = iCounter + 1
        end do
      end do
      if ( print_level .ge. 10 ) then
        write (*,*) 'AO basis overlap'
        do j = 1, nBas
          write(*,'(20F10.4)')(sAO(j,k),k = 1, j)
        end do
      end if
      s = 0.0
      iCounter = 0                                        ! reset s and iCounter; s will be re-used for the MO overlap


* open the file with the one-electron integrals (TRAONE)
      luOne = 30
      call DANAME(luOne,'TRAONE')

* read info from TRAONE
      iAd30 = 0
      call WR_MOTRA_Info(luOne,2,iAd30,
     &                   iToc, nToc, potNuc,nSym, nBas, nOrb,
     &                   nFrozen, nDMO, mxSym, basLabel, labelSize)

      write(*,*)'Info from TRAONE'
      write(*,'(A,I4)')'nBas    :',nBas
      write(*,'(A,I4)')'nFrozen :',nFrozen
      write(*,'(A,I4)')'nOrb    :',nOrb            ! number of basis functions in the common MO basis
      write(*,'(A,I4)')'nDeleted:',nDMO
      nOrbtt = (nOrb * (nOrb + 1)) / 2             ! number of elements in the  lower triangle

* open the file with the molecular orbitals and calculate sMO (not necessarily a unit matrix with NOCI)
      allocate( dummy(nBas) )
      open(11, file = 'COMMONORB', status = 'old')
      mark ='#INFO'
 63   read(11,'(A132)') line
      if (line(1:5).ne.mark) goto 63
      read(11,'(A132)') vectit
      write(*,*)
      write(*,*) vectit
      write(*,*)
      rewind(11)
      allocate ( vec(nOrb,nBas) )
      vec = 0.0
      mark = '#ORB'
 64   read(11,'(A132)') line
      if (line(1:4).ne.mark) goto 64
      do j = 1, nFrozen                                ! Skip the frozen orbitals, if any
        read(11,'(A132)') line
        read(11,'(5E22.14)') (dummy(k),k=1,nBas)
      end do
      do j = 1, nOrb
        read(11,'(A132)') line
        read(11,'(5E22.14)') (vec(j,k),k=1,nBas)
      end do
      write(*,202) 'Start overlap MOs for ',nOrb,' orbitals'
 202  format(A,I6,A)
      allocate( aux(nOrb,nBas))
      do k = 1, nOrb
        do l = 1, nBas
          do m = 1, nBas
            aux(k,l) = aux(k,l) + vec(k,m) * sAO(l,m)
          end do
        end do
      end do
      do j = 1, nOrb
        do k = 1, j
          iCounter = iCounter + 1
          do l = 1, nBas
            s(iCounter) = s(iCounter) + vec(j,l) * aux(k,l)
          end do
          if ( print_level .ge. 10 ) write(*,*) iCounter,s(iCounter)
          if ( mod(iCounter,int(nOrbtt/10)) .eq. 0 ) then
            b = 100.0*(float(iCounter))/float(nOrbtt)
            write(*,'(I3,A)') nint(b),'% done'
          end if
        end do
      end do 
      deallocate(dummy,aux)
      write(*,*) 

* allocate memory and read one-electron integrals
      allocate ( fock(nOrbtt) )
      allocate ( kinInt(nOrbtt) )
      allocate ( zero(nOrbtt) )
      zero = 0.0
      iAd30 = iToc(2)
      call dDAFILE(luOne,2,fock,nOrbtt,iAd30)
      iAd30 = iToc(3)
      call dDAFILE(luOne,2,kinInt,nOrbtt,iAd30)

      if (print_level .ge. 10 ) then
        write(*,*) 'S, V and T'
        do i = 1, nOrbtt
          write(*,'(i4,3F14.8)') i, s(i),fock(i),kinInt(i)
        end do
      endif

* Dump the one-electron integrals in 'filone'
      if (vectit(40:45).eq.'tau_MO') then
        title1 = 'Integrals in common MO basis ('
     &                       //vectit(40:57)//')'
      else
        title1 = 'Integrals in '//vectit(3:132)
      endif
      title2 = 'from openMolcas to GronOr by rdtraint '
      write(*,*) title1
      write(*,*) title2
      write(*,*)
      luOne_GronOR = 31
      write(filename,'(2a)')trim(Project),'.one'
      open(luOne_GronOR, file = filename, form = 'unformatted')
      if ( write_labels ) then
        write(luOne_GronOR) title1,title2,nOrbtt,potNuc,nOrb,nTraBuf,0
      else
        write(luOne_GronOR) title1,title2,nOrbtt,potNuc,nOrb,nTraBuf,1
      end if
      write(luOne_GronOR) (s(i),i=1,nOrbtt)
      write(luOne_GronOR) (zero(i),i=1,nOrbtt)
      write(luOne_GronOR) (fock(i),i=1,nOrbtt)
      write(luOne_GronOR) (/8421,-1,1/)     !no idea what this is

* open the file with the two-electron integrals (TRAINT)
      luTra = 50
      call DANAME_MF(lutra,'TRAINT')

* read table of contents of TRAINT
      iAd50 = 0
      call iDAFILE(luTra,2,iTraToc,nTraToc,iad50)

* calculate number of two-electron integrals, ltuvx
      ltuvx = 0
      nt = (nOrb * (nOrb + 1)) / 2
      do i = 1, nOrb
        do j = 1, i
          do k = 1, nt
            ltuvx = ltuvx + 1
          end do
          nt = nt - 1
        end do
      end do
      nFiles = int( ltuvx / (nTraBuf * nTraRec))                       ! number of completely filled 2-el. files
      allocate ( nRecs_onFile(nFiles+1) )
      allocate ( nInts_onFile(nFiles+1) )
      allocate ( filename_two_el(nFiles+1) )
      nRecs_onFile(nFiles+1) = 0
      nInts_onFile(nFiles+1) = 0
      filename_two_el(nFiles+1) = ' '
      luTwo_GronOR = 32
      do iFile = 1, nFiles
        nRecs_onFile(iFile) = nTraRec 
        nInts_onFile(iFile) = nTraRec * nTraBuf
        write(filename_two_el(iFile),'(2a,i3.3,a)')
     &            trim(Project),'_',iFile,'.two'
        filename = filename_two_el(iFile)
        stat = 0
        open( luTwo_GronOR, iostat=stat, file=filename, status='old' )
        if (stat .eq. 0) close(luTwo_GronOr, status='delete')          ! delete exisiting two-el files
      end do
      onLastFile = ltuvx - nFiles * nTraRec * nTraBuf                  ! number of integrals on the last file
      if ( onLastFile .gt. 0 ) then
        nFiles = nFiles + 1 
        nLastRecords = int(onLastFile/nTraBuf)                         ! number of records on the last file
        onLastRecord = onLastFile - nLastRecords*nTraBuf               ! integrals on the last record
        if ( onLastRecord .gt. 0 ) nLastRecords = nLastRecords + 1
        nRecs_onFile(nFiles) = nLastRecords
        nInts_onFile(nFiles) = onLastFile  
        write(filename_two_el(iFile),'(2a,i3.3,a)')
     &            trim(Project),'_',iFile,'.two'
        filename = filename_two_el(iFile)
        open( luTwo_GronOR, iostat=stat, file=filename, status='old' )
        if (stat .eq. 0) close(luTwo_GronOr, status='delete')
      end if
      totRecords = sum(nRecs_onFile)
* some additional info on the 2-el ints is expected on luOne_GronOR
      write(luOne_GronOR) ltuvx
      write(luOne_GronOR) nFiles
      write(luOne_GronOR) (nRecs_onFile(iFile),iFile=1,nFiles)         ! number of records per file
      write(luOne_Gronor) (nInts_onFile(iFile),iFile=1,nFiles) ! number of integrals per file
      close(luOne_Gronor)
      write(*,*)' Number of 2 el. integrals          :',ltuvx
      write(*,*)' Number of integral files           :',nFiles
      if ( nFiles .gt. 1 ) then
        write(*,*)' Number of integrals on last file   :',onLastFile
      end if
      write(*,*)' Total number of records            :',totRecords
      if ( nFiles .gt. 1 ) then
        write(*,*)' Number of records on last file     :',
     &         nRecs_onFile(nFiles)
      end if
      write(*,*)' Number of integrals on last record :',
     &       onLastFile - (nRecs_onFile(nFiles)-1) * nTraBuf
      if ( write_labels ) then
        write(*,*) ' --- Integral labels are written ---'
      else
        write(*,*) ' --- Integral labels are not written ---'
      end if 
      write(*,*)

* set up a small array for generating the labels i, j, k and l label of the 2-el integrals
      allocate( kl(nOrbtt,2) )
      kl = 0
      iCounter = 0
      do l=1,nOrb
        do k = 1, l
          iCounter = iCounter + 1
          kl(iCounter,1) = k
          kl(iCounter,2) = l
        end do
      end do
      if ( print_level .ge. 10 ) then
        write(*,*) 'lower triangle of the k-l labels'
        do l = 1, nOrbtt
          write(*,*) l,kl(l,1),kl(l,2)
        end do
      end if

      inquire( iolength = nrec ) traBuf(1)
      if ( write_labels ) then
        RecordLength = ( 2 * ntraBuf + 2 ) * nrec
      else
        RecordLength = ( ntraBuf + 2 ) * nrec
      end if
      if ( print_level .ge. 10 ) then
        write(*,*)'nrec and Record length:',nrec,recordLength
      end if
      iCounter = 0
      ii_start = 1
      jj_start = 1
      ilast = 0
      nonZeroInt = 0
      recordNumber = 0
      nInts = nTraBuf
      do iFile = 1, nFiles
        recNumber2 = 0
        filename = filename_two_el(iFile)
        open(luTwo_GronOR, file = filename, form = 'unformatted', 
     &                   access = 'direct', recl = RecordLength)
        do iRec = 1, nRecs_onFile(iFile) 
          recordNumber = recordNumber + 1
          recNumber2 = recNumber2 + 1
          if (recordNumber .eq. totRecords) then
            ilast = 1 
            if (onLastRecord .gt. 0) nInts = onLastRecord
          end if
          call dDAFILE(luTra,2,traBuf,nInts,iad50)
          do n = 1, nInts
            if (abs(traBuf(n)) .lt. almostZero) nonZeroInt=nonZeroInt+1
          end do
          do ii = ii_start, nOrbtt
            do jj = jj_start, nOrbtt
              iCounter = iCounter + 1
              if (iCounter .le. nInts) then
                i = kl(ii,1)
                j = kl(ii,2)
                k = kl(jj,1)
                l = kl(jj,2)
                labels((iCounter-1)*4+1) = i
                labels((iCounter-1)*4+2) = j
                labels((iCounter-1)*4+3) = k
                labels((iCounter-1)*4+4) = l
                traBuf(iCounter) = traBuf(iCounter)*scal(i,j,k,l)
                if ( print_level .ge. 20 ) write(*,'(5i4,F8.3,F12.6)')
     &             iCounter,i,j,k,l,scal(i,j,k,l),traBuf(iCounter)
                if (( print_level .ge. 10 ) .and. (print_level .lt. 20 )
     &                .and. (iRec .eq. 1) .and. (iCounter .le. 10 )) 
     &                  write(*,'(4I4,F18.12)') i,j,k,l,traBuf(iCounter)
              else    
                goto 59
              end if
            end do
            jj_start = ii + 1
          end do
 59       ii_start = ii
          jj_start = jj 
          iCounter = 0
          if ( write_labels ) then                                 !  Dump the integrals on the 2-el file
            write(luTwo_GronOR,rec=recNumber2)(traBuf(n),n=1,nInts),
     &                      (labels(n),n=1,4*nInts),nInts,ilast
          else
            write(luTwo_GronOR,rec=recNumber2)(traBuf(n),n=1,nInts),
     &                      nInts,ilast
          end if
        end do
        close(luTwo_GronOR)
      end do
      write(*,'(A,ES8.1,A,I8)')'Number of integrals smaller than ',
     &                                    almostZero, ' :  ',nonZeroInt
      percentage = 100*(float(nonZeroInt)/float(ltuvx))
      if ( percentage .ge. 1e-2) then
        write(*,'(A,F6.2,A)') '( ',percentage,' % of the total)'
      else
        write(*,'(A,F6.2,A)') '(less than ',1e-2,' % of the total)'
      end if
* close the files
      call DACLOS(luOne)
      call DACLOS(luTra)

* deallocate
      deallocate (sAO)
      deallocate (vec)
      deallocate (s)
      deallocate (fock)
      deallocate (kinInt)


* fill the sym file with info
      write(filename,'(2a)')trim(Project),'.sym'
      open(15,file=trim(filename))
      write(15,'(A)') ' * * * General info from OpenMolcas to GronOR'
      Call Get_cArray('Seward Title',Header,144)
      empty = .true.
      do i = 1, 72
        if (Header(i:i) .ne. ' ' ) empty = .false.
      end do
      if ( empty ) Header(1:28) = ' (No title provided by user)'
      write(15,'(A)') Header(1:72)
      write(15,'(A)') Header(73:144)
      Call Get_nAtoms_All(nAtoms)
      write(15,'(A,I4)') 'number of atoms: ',nAtoms
      allocate( coord(3 * nAtoms) )
      allocate( AtomLbl(nAtoms) )
      allocate( BasfnLbl(nBas) )                              ! see comment 1
      allocate( zNuc(nAtoms) )
      allocate( nCntr(nAtoms,7) )
      Call Get_Coord_All(coord,nAtoms)
      Call Get_cArray('Unique Atom Names',AtomLbl,LblL*nAtoms)
      Call Get_cArray('Unique Basis Name',BasfnLbl,nBas*LblL8)
      Call Get_dArray('Nuclear charge',zNuc,nAtoms)
      nCntr = 0
      iAtom = 1
      if (BasfnLbl(1)(9:9).eq.'s') nCntr(1,1)=1
      if (BasfnLbl(1)(9:9).eq.'p') nCntr(1,2)=1
      if (BasfnLbl(1)(9:9).eq.'d') nCntr(1,3)=1
      if (BasfnLbl(1)(9:9).eq.'f') nCntr(1,4)=1
      if (BasfnLbl(1)(9:9).eq.'g') nCntr(1,5)=1
      if (BasfnLbl(1)(9:9).eq.'h') nCntr(1,6)=1
      if (BasfnLbl(1)(9:9).eq.'i') nCntr(1,7)=1
      do j = 2, nBas
        if ( BasfnLbl(j)(1:6) .ne. BasfnLbl(j-1)(1:6) ) 
     &                                  iAtom = iAtom + 1   ! next atom
        if (BasfnLbl(j)(9:9).eq.'s') nCntr(iAtom,1)=nCntr(iAtom,1)+1
        if (BasfnLbl(j)(9:9).eq.'p') nCntr(iAtom,2)=nCntr(iAtom,2)+1
        if (BasfnLbl(j)(9:9).eq.'d') nCntr(iAtom,3)=nCntr(iAtom,3)+1
        if (BasfnLbl(j)(9:9).eq.'f') nCntr(iAtom,4)=nCntr(iAtom,4)+1
        if (BasfnLbl(j)(9:9).eq.'g') nCntr(iAtom,5)=nCntr(iAtom,5)+1
        if (BasfnLbl(j)(9:9).eq.'h') nCntr(iAtom,6)=nCntr(iAtom,6)+1
        if (BasfnLbl(j)(9:9).eq.'i') nCntr(iAtom,7)=nCntr(iAtom,7)+1
      end do
      iCounter = 1
      lAO = 's  p  d  f  g  h  i'
      write(15,'(6x,A,10x,2A,5x,A)')
     & 'Atom','x             y             z',
     &         '          Znuc',lAO
      do iAtom = 1, nAtoms
        write(15,201)iAtom,AtomLbl(iAtom),(coord(k),k=iCounter,
     &         iCounter+2),zNuc(iAtom),(nCntr(iAtom,l)/(2*(l-1)+1),
     &         l=1,7)
        iCounter = iCounter + 3
      end do
 201  format (I4,2x,A6,3F14.8,2x,F7.2,3x,7I3)
      call get_dscalar('Total Charge',totCharge)
      write(15,'(a,F15.8)') 'Total charge = ',totCharge
      if (write_fragIDs) then
        write(*,*) 'fragment Labels'
        do i = 1, nFragments
          write(15,'(20(a2,3x))')fragmentLabels(i,:)
        end do
      endif
      end

      function scal(i,j,k,l)
      integer   :: i,j,k,l
      real (kind = 8)      :: scal
      scal = 1.0
      if ( i .eq. j ) scal = scal * 0.5
      if ( k .eq. l ) scal = scal * 0.5
      if ( ( i. eq. k .and. j .eq. l )
     &     .or.
     &   ( i .eq. l .and. j .eq. k ) ) scal = scal * 0.5
      return 
      end 

! Comment 1: The number of s, p, d etc. functions per atom is not known outside Molcas, this info is not
! written to any file (ONEINT, RUNFILE, TRAINT, JOBIPH). Therefore we have to determine it in an indirect
! way by comparing the basis set labels. If this interface is integrated in Molcas, the info is directly
! available through common blocks.


      subroutine read_input
      use input_rdtraint_data
      implicit none

      integer, parameter                   :: nKeys = 6
      integer                              :: iKey,jj
      integer                              :: filesize
      logical                              :: all_ok=.true.
      logical, dimension(nKeys)            :: hit = .false.
      character (len=4)                    :: key
      character (len=4), dimension(nKeys)  :: keyword
      character (len=132)                  :: line

      data keyword /'PROJ','FILE','PRIN','WRIT','SMAL','FRAG','LABE'/

* * Keywords * * * * 
*
*      PROJect         : prefix for all filename generated by rdtraint
*      FILEsize        : Maximum size in MBytes (approx) of the 2-el. integral files
*      PRINT level     : x < 10 , standard
*                        10 =< x < 20  extra (debug) info, e.g. overal AO basis and 1-el. integrals
*                        x >= 20 all integrals are printed
*      WRITe labels    : Integral labels will be written on the 2-el. integral file(s)
*                      : Default is not to write the labels
*      SMALl integrals : Threshold for considering an integral small,
*                        for info only (all integrals are written to file)
*      FRAGments       : Same keyword as for common_basis
*
*      LABEls          : Labels for the fragment wave functions
*
*********************

* defaults
      Project       = project
      filesize      = 2000           ! 2000 MByte (Approx)
      print_level   = 1
      write_labels  = .false.
      almostZero    = 1.0e-10
      write_fragIDs = .false.
       

      do while (all_ok)
        read(5,*,iostat=jj) line
        key = adjustl(line)
        call capitalize(key)
        do iKey = 1, nKeys
          if ( key .eq. keyword(iKey) ) hit(iKey) = .true.
        end do
        if (  jj .lt. 0 ) all_ok = .false.
      end do

      if ( (hit(7)) .and. (.not.hit(6)) ) then
        write(*,*) 'LABEls cannot be used without FRAGments'
        stop
      end if

      do iKey = 1, nKeys
        if ( hit(iKey) ) then
          select case(iKey)
            case(1)
              call locate('PROJ')
              read(*,*) project
              project = trim(project)
            case(2)
              call locate('FILE')
              read(*,*) filesize 
            case(3)
              call locate('PRIN')
              read(*,*) print_level
            case(4)
              call locate('WRIT')
              write_labels = .true.
            case(5)
              call locate('SMAL')
              read(*,*) almostZero
            case(6)
              call locate('FRAG')
              read(*,*) nFragments
              allocate(nVec(nFragments))
              read(*,*) (nVec(iFrag), iFrag = 1, nFragments)
            case(7)
              call locate('LABE')
              write_fragIDs = .true.
              allocate(fragLabels(nFragments,maxval(nVec)))
              do iFrag = 1, nFragments
                read(*,*) (fragLabels(iFrag,j),j=1,nVec(iFrag))
              end do
          end select
        end if
      end do
      if ( print_level .le. 0 ) print_level = 1
      if ( almostZero .lt. 0 ) almostZero = -almostZero
      filesize = filesize  * 1.0e6
      if ( write_labels ) then
        nTraRec = int(filesize / (2*8*9600) )
      else
        nTraRec = int(filesize / (8*9600) )
      endif  
      return
      end subroutine read_input        



      subroutine locate(string)
      implicit none
      character(4)   ::  string,string2
      character(132) ::  line
      rewind(5)
 40   read(5,*) line
      string2=adjustl(line)
      call capitalize(string2)
      if (string2.ne.string) goto 40
      return
      end subroutine locate


      subroutine capitalize(string)
      implicit none
      integer      :: i
      character(*) string

      do i = 1, len(string)
        if (ichar(string(i:i)).gt.96) then
          string(i:i) = char(ichar(string(i:i))-32)
        endif
      end do
      return
      end subroutine capitalize 
