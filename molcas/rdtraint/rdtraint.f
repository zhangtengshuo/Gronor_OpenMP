      program read_traint
* Code for writing the integrals in the common MO basis generated by
* OpenMolcas in a format that can be processed by GronOR.
* The Project.sys file only contains some general info on coordinates,
* basis set, fragments and mebf.
*
* 
* 5 files from OpenMolcas are needed:
*   ONEINT        AO overlap matrix of the system
*   RUNFILE       General info
*   COMMONORB     Common MO basis in OpenMolcas format 
*   TRAONE        Transformed 1-el. integrals
*   TRAINT        Transformed 2-el. integrals
*
* To initialize OpenMolcas memory management, MOLCAS_MEM needs to be
* defined
*   > export MOLCAS_MEM=1000 (or any other number you like)
*

      implicit none

      integer, parameter                :: nToc = 64
      integer, parameter                :: nTraToc = 106
      integer, parameter                :: mxSym = 1, maxBfn = 10000
      integer, parameter                :: labelSize = 2 * maxBfn * 4
      integer, parameter                :: LblL  = 6           !LenIN  in OpenMolcas
      integer, parameter                :: LblL8 = lblL + 8    !LenIN8 in OpenMolcas
      integer, parameter                :: nTraBuf = 9600
      integer                           :: luTra, luOne, iAd30, iAd50
      integer                           :: luOne_GronOR,luTwo_GronOR
      integer                           :: nSym, nOrbtt
      integer                           :: i,j,k,l,m,nt,ltuvx,ii,jj,n
      integer                           :: nonZeroInt
      integer                           :: iCounter
      integer                           :: ii_start,jj_start
      integer                           :: ilast,nrec
      integer                           :: recordNumber,recordLength
      integer                           :: recNumber2
      integer                           :: lTriangle
      integer                           :: iRC,iOpt,iComponent,iSymlbl
      integer                           :: iAtom,nAtoms
      integer (kind=2), dimension(4*nTraBuf) :: labels

      integer                           :: nBas,nOrb,nDMO,nFrozen
      integer, allocatable              :: nCntr(:,:)
      integer, allocatable              :: kl(:,:)
      integer, dimension(nToc)          :: iToc
      integer, dimension(nTraToc)       :: iTraToc
      real (kind=8)                     :: potNuc,scal,almostZero,
     &                                     percentage
      real (kind=8), dimension(nTraBuf) :: traBuf

      real (kind=8), allocatable        :: mltpInts(:),sAO(:,:),aux(:,:)
      real (kind=8), allocatable        :: sMO(:)
      real (kind=8), allocatable        :: DM(:,:,:),QM(:,:,:)
      real (kind=8), allocatable        :: vec(:,:)
      real (kind=8), allocatable        :: kinInt(:)
      real (kind=8), allocatable        :: fock(:)
      real (kind=8), allocatable        :: zero(:)
      real (kind=8), allocatable        :: dummy(:)
      real (kind=8), allocatable        :: coord(:),znuc(:)
      real (kind=8), allocatable        :: dipole(:,:)
      real (kind=8), allocatable        :: quadrupole(:,:)
      real (kind=8), allocatable        :: CoM(:)
      character (len = 1), dimension(labelSize) :: basLabel
      character (len = LblL), allocatable   :: AtomLbl(:)
      character (len = LblL8), allocatable  :: BasfnLbl(:)
      character (len = 5)               :: mark
      character (len = 19)              :: lAO
      character (len = 80)              :: title1,title2
      character (len = 80)              :: Project,combas
      character (len = 84)              :: filename
      character (len = 80), allocatable   :: filename_two_el(:)
      character (len = 132)             :: line,vectit
      character (len = 144)             :: Header
      logical                           :: empty

      integer              :: nTraRec, print_level
      integer, allocatable :: nRecs_onFile(:)
      integer, allocatable :: nInts_onFile(:)
      integer              :: nFiles,iFile
      integer              :: onlastrecord,nlastrecords,totRecords
      integer              :: iRec,nInts,onLastFile,stat
      logical              :: write_labels

      call read_input(Project,print_level,write_labels,nTraRec,
     &                                       almostZero,combas)
* open the ONEINT file to access the AO overlap matrix (needed to calculate sMO)
      nBas = 0
      call NameRun('RUNFILE')              ! ONEINT cannot be accessed without RUNFILE
      call Get_iScalar('nSym',nSym)
      if ( nSym .ne. 1 ) then
        write(*,*) '  Symmetry is not implemented in GronOR'
        write(*,*) 'Remove the symmetry elements and come back'
        stop
      end if
      call Get_iArray('nBas',nBas,nSym)
      lTriangle = nBas * (nBas + 1) / 2
      allocate ( mltpInts(lTriangle+4) )
      allocate ( sAO(nBas,nBas) )
      allocate ( DM(nBas,nBas,3) )
      allocate ( QM(nBas,nBas,6) )
! open the ONEINT file
      LuOne = 77
      iRc=-1
      iOpt=0
      call OpnOne(iRC,iOpt,'ONEINT',LuOne)
      if (iRC.ne.0) write(6,*) 'Something went wrong opening ONEINT'
! read the overlap integrals in the AO basis
      sAO = 0.0d0
      iRC = -1
      iOpt = 2
      iComponent = 1
      mltpInts = 0.0d0
      iSymLbl = 1
      call RdOne(iRC,iOpt,'Mltpl  0',iComponent,mltpInts,iSymLbl)
      if (iRC.ne.0) write(6,*) 'Something went wrong reading the ',
     &                              'overlap integrals from ONEINT'
      iCounter = 1
      do j = 1, nBas
        do k = 1, j
          sAO(j,k) = mltpInts(iCounter)
          sAO(k,j) = mltpInts(iCounter)
          iCounter = iCounter + 1
        end do
      end do
      if ( print_level .ge. 10 ) then
        write (*,*) 'AO basis overlap'
        do j = 1, nBas
          write(*,'(20F10.4)')(sAO(j,k),k = 1, j)
        end do
      end if
! read the dipole integrals in the AO basis
      DM = 0.0d0
      do iComponent = 1,3
        mltpInts = 0.0d0
        iRC = -1
        iOpt = 2
        iSymLbl = 1
        call RdOne(iRC,iOpt,'Mltpl  1',iComponent,mltpInts,iSymLbl)
        if (iRC.ne.0) write(6,*) 'Something went wrong reading the ',
     &                              'dipole integrals from ONEINT'
        iCounter = 0
        do j = 1, nBas
          do k = 1, j
            iCounter = iCounter + 1
            DM(j,k,iComponent) = mltpInts(iCounter)
            DM(k,j,iComponent) = mltpInts(iCounter)
          enddo
        enddo
      enddo
      if ( print_level .ge. 10 ) then
        write (*,'(a)') 'Dipole moment X component'
        do j = 1, nBas
          write(*,'(20F10.4)')(DM(j,k,1),k = 1, j)
        end do
        write (*,'(a)') 'Dipole moment Y component'
        do j = 1, nBas
          write(*,'(20F10.4)')(DM(j,k,2),k = 1, j)
        end do
        write (*,'(a)') 'Dipole moment Z component'
        do j = 1, nBas
          write(*,'(20F10.4)')(DM(j,k,3),k = 1, j)
        end do
      end if
! read the quadrupole integrals in the AO basis
      QM = 0.0d0
      do iComponent = 1,6
        mltpInts = 0.0d0
        iRC = -1
        iOpt = 2
        iSymLbl = 1
        call RdOne(iRC,iOpt,'Mltpl  2',iComponent,mltpInts,iSymLbl)
        if (iRC.ne.0) write(6,*) 'Something went wrong reading the ',
     &                              'quadrupole integrals from ONEINT'
        iCounter = 0
        do j = 1, nBas
          do k = 1, j
            iCounter = iCounter + 1
            QM(j,k,iComponent) = mltpInts(iCounter)
            QM(k,j,iComponent) = mltpInts(iCounter)
          enddo
        enddo
      enddo
      if ( print_level .ge. 10 ) then
        write (*,'(a)') 'Quadrupole moment XX component'
        do j = 1, nBas
          write(*,'(20F10.4)')(QM(j,k,1),k = 1, j)
        end do
        write (*,'(a)') 'Quadrupole moment XY component'
        do j = 1, nBas
          write(*,'(20F10.4)')(QM(j,k,2),k = 1, j)
        end do
        write (*,'(a)') 'Quadrupole moment XZ component'
        do j = 1, nBas
          write(*,'(20F10.4)')(QM(j,k,3),k = 1, j)
        end do
        write (*,'(a)') 'Quadrupole moment YY component'
        do j = 1, nBas
          write(*,'(20F10.4)')(QM(j,k,4),k = 1, j)
        end do
        write (*,'(a)') 'Quadrupole moment YZ component'
        do j = 1, nBas
          write(*,'(20F10.4)')(QM(j,k,5),k = 1, j)
        end do
        write (*,'(a)') 'Quadrupole moment ZZ component'
        do j = 1, nBas
          write(*,'(20F10.4)')(QM(j,k,6),k = 1, j)
        end do
      end if
! close the OneInt file 
      iRC = -1
      iOpt = 0
      call ClsOne(iRc,iOpt)
      if (iRC.ne.0) write(6,*) 'Something went wrong closing ONEINT'
      deallocate( mltpInts )

* open the file with the transformed one-electron integrals (TRAONE)
      luOne = 30
      call DANAME(luOne,'TRAONE')

* read info from TRAONE
      iAd30 = 0
      call WR_MOTRA_Info(luOne,2,iAd30,
     &                   iToc, nToc, potNuc,nSym, nBas, nOrb,
     &                   nFrozen, nDMO, mxSym, basLabel, labelSize)

      if ( print_level .ge. 10 ) then
        write(*,*)'Info from TRAONE'
        write(*,'(A,I4)')'nBas    :',nBas
        write(*,'(A,I4)')'nFrozen :',nFrozen
        write(*,'(A,I4)')'nOrb    :',nOrb            ! number of basis functions in the common MO basis
        write(*,'(A,I4)')'nDeleted:',nDMO
      end if
      nOrbtt = (nOrb * (nOrb + 1)) / 2             ! number of elements in the  lower triangle

* open the file with the molecular orbitals and calculate sMO (not necessarily a unit matrix with NOCI)
      allocate( dummy(nBas) )
      open(11, file = 'COMMONORB', status = 'old')
      mark ='#INFO'
 63   read(11,'(A132)') line
      if (line(1:5).ne.mark) goto 63
      read(11,'(A132)') vectit
      write(*,*)
      write(*,*) vectit
      write(*,*)
      rewind(11)
      allocate ( vec(nOrb,nBas) )
      vec = 0.0
      mark = '#ORB'
 64   read(11,'(A132)') line
      if (line(1:4).ne.mark) goto 64
      do j = 1, nFrozen                                ! Skip the frozen orbitals, if any
        read(11,'(A132)') line
        read(11,'(5E22.14)') (dummy(k),k=1,nBas)
      end do
      do j = 1, nOrb
        read(11,'(A132)') line
        read(11,'(5E22.14)') (vec(j,k),k=1,nBas)
      end do
      allocate( aux(nOrb,nBas))
      allocate( sMO(nOrbtt))
      aux = 0.0d0
      sMO = 0.0d0
      do k = 1, nOrb
        do l = 1, nBas
          do m = 1, nBas
            aux(k,l) = aux(k,l) + vec(k,m) * sAO(l,m)
          end do
        end do
      end do
      iCounter = 0
      do j = 1, nOrb
        do k = 1, j
          iCounter = iCounter + 1
          do l = 1, nBas
            sMO(iCounter) = sMO(iCounter) + vec(j,l) * aux(k,l)
          end do
          if ( print_level .ge. 10 ) write(*,'(i6,F22.14)') iCounter,
     &                                         sMO(iCounter)
        end do
      end do 
      deallocate(dummy)
      write(*,*) 

* allocate memory and read one-electron integrals
      allocate ( fock(nOrbtt) )
      allocate ( kinInt(nOrbtt) )
      allocate ( zero(nOrbtt) )
      zero = 0.0
      iAd30 = iToc(2)
      call dDAFILE(luOne,2,fock,nOrbtt,iAd30)
      iAd30 = iToc(3)
      call dDAFILE(luOne,2,kinInt,nOrbtt,iAd30)

      if (print_level .ge. 10 ) then
        write(*,*) 'S, V and T'
        do i = 1, nOrbtt
          write(*,'(i5,3F14.8)') i, sMO(i),fock(i),kinInt(i)
        end do
      endif

! Transform the dipole moment integrals to the common basis
      allocate (dipole(nOrbtt,3))
      dipole = 0.0d0
      do iComponent = 1, 3
        iCounter = 0
        aux = 0.0d0
        do k = 1, nOrb
          do l = 1, nBas
            do m = 1, nBas
              aux(k,l) = aux(k,l) + vec(k,m) * DM(l,m,iComponent)
            end do
          end do
        end do
        do j = 1, nOrb
          do k = 1, j
            iCounter = iCounter + 1
            do l = 1, nBas
              dipole(iCounter,iComponent) = dipole(iCounter,iComponent)
     &           + vec(j,l) * aux(k,l)
            end do
          end do
        end do
      end do
      if ( print_level .ge. 10 ) then
        write(*,'(2a)') 'Dipole integrals transformed to the ',
     &                  'common basis'
        do i = 1, nOrbtt
          write(*,'(i4,3F14.8)') i,(dipole(i,iComponent),iComponent=1,3)
        end do
      end if
! Transform the quadrupole moment integrals to the common basis
      allocate (quadrupole(nOrbtt,6))
      quadrupole = 0.0d0
      do iComponent = 1, 6
        iCounter = 0
        aux = 0.0d0
        do k = 1, nOrb
          do l = 1, nBas
            do m = 1, nBas
              aux(k,l) = aux(k,l) + vec(k,m) * QM(l,m,iComponent)
            end do
          end do
        end do
        do j = 1, nOrb
          do k = 1, j
            iCounter = iCounter + 1
            do l = 1, nBas
              quadrupole(iCounter,iComponent) = 
     &            quadrupole(iCounter,iComponent) + vec(j,l) * aux(k,l)
            end do
          end do
        end do
      end do
      if ( print_level .ge. 10 ) then
        write(*,'(2a)') 'Quadrupole integrals transformed to the ',
     &                  'common basis'
        do i = 1, nOrbtt
          write(*,'(i4,6F14.8)') i,(quadrupole(i,iComponent),
     &                                              iComponent=1,6)
        end do
      end if    
        

* Dump the one-electron integrals in 'filone'
      if (vectit(40:45).eq.'tau_MO') then
        title1 = 'Integrals in common MO basis ('
     &                       //vectit(40:57)//')'
      else
        title1 = 'Integrals in '//vectit(3:132)
      endif
      title2 = 'from openMolcas to GronOr by rdtraint '
      write(*,*) title1
      write(*,*) title2
      luOne_GronOR = 31
      write(filename,'(a,a4)')trim(Project),'.one'
      open(luOne_GronOR, file = filename, form = 'unformatted')
      if ( write_labels ) then
        write(luOne_GronOR) title1,title2,nOrbtt,potNuc,nOrb,nTraBuf,0
      else
        write(luOne_GronOR) title1,title2,nOrbtt,potNuc,nOrb,nTraBuf,1
      end if
      write(luOne_GronOR) (sMO(i),i=1,nOrbtt)
      write(luOne_GronOR) (zero(i),i=1,nOrbtt)
      write(luOne_GronOR) (fock(i),i=1,nOrbtt)
      write(luOne_GronOR) (dipole(i,1),i=1,nOrbtt)
      write(luOne_GronOR) (dipole(i,2),i=1,nOrbtt)
      write(luOne_GronOR) (dipole(i,3),i=1,nOrbtt)
      write(luOne_GronOR) (quadrupole(i,1),i=1,nOrbtt)
      write(luOne_GronOR) (quadrupole(i,2),i=1,nOrbtt)
      write(luOne_GronOR) (quadrupole(i,3),i=1,nOrbtt)
      write(luOne_GronOR) (quadrupole(i,4),i=1,nOrbtt)
      write(luOne_GronOR) (quadrupole(i,5),i=1,nOrbtt)
      write(luOne_GronOR) (quadrupole(i,6),i=1,nOrbtt)
      write(luOne_GronOR) (/8421,-1,1/)     !no idea what this is

* open the file with the two-electron integrals (TRAINT)
      luTra = 50
      call DANAME_MF(lutra,'TRAINT')

* read table of contents of TRAINT
      iAd50 = 0
      call iDAFILE(luTra,2,iTraToc,nTraToc,iad50)

* calculate number of two-electron integrals, ltuvx
      ltuvx = 0
      nt = (nOrb * (nOrb + 1)) / 2
      do i = 1, nOrb
        do j = 1, i
          do k = 1, nt
            ltuvx = ltuvx + 1
          end do
          nt = nt - 1
        end do
      end do
      nFiles = int( ltuvx / (nTraBuf * nTraRec))                       ! number of completely filled 2-el. files
      allocate ( nRecs_onFile(nFiles+1) )
      allocate ( nInts_onFile(nFiles+1) )
      allocate ( filename_two_el(nFiles+1) )
      nRecs_onFile(nFiles+1) = 0
      nInts_onFile(nFiles+1) = 0
      filename_two_el(nFiles+1) = ' '
      luTwo_GronOR = 32
      do iFile = 1, nFiles
        nRecs_onFile(iFile) = nTraRec 
        nInts_onFile(iFile) = nTraRec * nTraBuf
        write(filename_two_el(iFile),'(3a,i3.3,a)')
     &     trim(Project),trim(combas),'_',iFile,'.two'
        filename = filename_two_el(iFile)
        stat = 0
        open( luTwo_GronOR, iostat=stat, file=filename, status='old' )
        if (stat .eq. 0) close(luTwo_GronOr, status='delete')          ! delete exisiting two-el files
      end do
      onLastFile = ltuvx - nFiles * nTraRec * nTraBuf                  ! number of integrals on the last file
      if ( onLastFile .gt. 0 ) then
        nFiles = nFiles + 1 
        nLastRecords = int(onLastFile/nTraBuf)                         ! number of records on the last file
        onLastRecord = onLastFile - nLastRecords*nTraBuf               ! integrals on the last record
        if ( onLastRecord .gt. 0 ) nLastRecords = nLastRecords + 1
        nRecs_onFile(nFiles) = nLastRecords
        nInts_onFile(nFiles) = onLastFile  
        write(filename_two_el(iFile),'(2a,i3.3,a)')
     &            trim(Project),'_',iFile,'.two'
        filename = filename_two_el(iFile)
        open( luTwo_GronOR, iostat=stat, file=filename, status='old' )
        if (stat .eq. 0) close(luTwo_GronOr, status='delete')
      end if
      totRecords = sum(nRecs_onFile)
* some additional info on the 2-el ints is expected on luOne_GronOR
      write(luOne_GronOR) ltuvx
      write(luOne_GronOR) nFiles
      write(luOne_GronOR) (nRecs_onFile(iFile),iFile=1,nFiles)         ! number of records per file
      write(luOne_Gronor) (nInts_onFile(iFile),iFile=1,nFiles) ! number of integrals per file
      close(luOne_Gronor)
      write(*,*)' Number of 2 el. integrals          :',ltuvx
      write(*,*)' Number of integral files           :',nFiles
      if ( nFiles .gt. 1 ) then
        write(*,*)' Number of integrals on last file   :',onLastFile
      end if
      write(*,*)' Total number of records            :',totRecords
      if ( nFiles .gt. 1 ) then
        write(*,*)' Number of records on last file     :',
     &         nRecs_onFile(nFiles)
      end if
      write(*,*)' Number of integrals on last record :',
     &       onLastFile - (nRecs_onFile(nFiles)-1) * nTraBuf
      if ( write_labels ) then
        write(*,*) ' --- Integral labels are written ---'
      else
        write(*,*) ' --- Integral labels are not written ---'
      end if 
      write(*,*)

* set up a small array for generating the labels i, j, k and l label of the 2-el integrals
      allocate( kl(nOrbtt,2) )
      kl = 0
      iCounter = 0
      do l=1,nOrb
        do k = 1, l
          iCounter = iCounter + 1
          kl(iCounter,1) = k
          kl(iCounter,2) = l
        end do
      end do
      if ( print_level .ge. 10 ) then
        write(*,*) 'lower triangle of the k-l labels'
        do l = 1, nOrbtt
          write(*,*) l,kl(l,1),kl(l,2)
        end do
      end if

      inquire( iolength = nrec ) traBuf(1)
      if ( write_labels ) then
        RecordLength = ( 2 * ntraBuf + 2 ) * nrec
      else
        RecordLength = ( ntraBuf + 2 ) * nrec
      end if
      if ( print_level .ge. 10 ) then
        write(*,*)'nrec and Record length:',nrec,recordLength
      end if
      iCounter = 0
      ii_start = 1
      jj_start = 1
      ilast = 0
      nonZeroInt = 0
      recordNumber = 0
      nInts = nTraBuf
      do iFile = 1, nFiles
        recNumber2 = 0
        filename = filename_two_el(iFile)
        open(luTwo_GronOR, file = filename, form = 'unformatted', 
     &                   access = 'direct', recl = RecordLength)
        do iRec = 1, nRecs_onFile(iFile) 
          recordNumber = recordNumber + 1
          recNumber2 = recNumber2 + 1
          if (recordNumber .eq. totRecords) then
            ilast = 1 
            if (onLastRecord .gt. 0) nInts = onLastRecord
          end if
          call dDAFILE(luTra,2,traBuf,nInts,iad50)
          do n = 1, nInts
            if (abs(traBuf(n)) .lt. almostZero) nonZeroInt=nonZeroInt+1
          end do
          do ii = ii_start, nOrbtt
            do jj = jj_start, nOrbtt
              iCounter = iCounter + 1
              if (iCounter .le. nInts) then
                i = kl(ii,1)
                j = kl(ii,2)
                k = kl(jj,1)
                l = kl(jj,2)
                labels((iCounter-1)*4+1) = i
                labels((iCounter-1)*4+2) = j
                labels((iCounter-1)*4+3) = k
                labels((iCounter-1)*4+4) = l
                traBuf(iCounter) = traBuf(iCounter)*scal(i,j,k,l)
                if ( print_level .ge. 20 ) write(*,'(5i4,F8.3,F12.6)')
     &             iCounter,i,j,k,l,scal(i,j,k,l),traBuf(iCounter)
                if (( print_level .ge. 10 ) .and. (print_level .lt. 20 )
     &                .and. (iRec .eq. 1) .and. (iCounter .le. 10 )) 
     &                  write(*,'(4I4,F18.12)') i,j,k,l,traBuf(iCounter)
              else    
                goto 59
              end if
            end do
            jj_start = ii + 1
          end do
 59       ii_start = ii
          jj_start = jj 
          iCounter = 0
          if ( write_labels ) then                                 !  Dump the integrals on the 2-el file
            write(luTwo_GronOR,rec=recNumber2)(traBuf(n),n=1,nInts),
     &                      (labels(n),n=1,4*nInts),nInts,ilast
          else
            write(luTwo_GronOR,rec=recNumber2)(traBuf(n),n=1,nInts),
     &                      nInts,ilast
          end if
        end do
        close(luTwo_GronOR)
      end do
      write(*,'(A,ES8.1,A,I10)')'Number of integrals smaller than ',
     &                                    almostZero, ' :  ',nonZeroInt
      percentage = 100*(float(nonZeroInt)/float(ltuvx))
      if ( percentage .ge. 1e-2) then
        write(*,'(A,F6.2,A)') '( ',percentage,' % of the total)'
      else
        write(*,'(A,F6.2,A)') '(less than ',1e-2,' % of the total)'
      end if
* close the files
      call DACLOS(luOne)
      call DACLOS(luTra)

* deallocate
      deallocate (sAO)
      deallocate (vec)
      deallocate (fock)
      deallocate (kinInt)
      deallocate (zero)
      deallocate (DM)
      deallocate (QM)
      deallocate (dipole)
      deallocate (quadrupole)
      deallocate (aux)
      deallocate (nRecs_onFile)
      deallocate (nInts_onFile)
      deallocate (filename_two_el)
      deallocate (kl)

* fill the sys file with info
      write(filename,'(2a)')trim(Project),'.sys'
      open(15,file=trim(filename),position='append')
      write(15,'(A)') ' * * * General info from OpenMolcas to GronOR'
      Call Get_cArray('Seward Title',Header,144)
      empty = .true.
      do i = 1, 72
        if (Header(i:i) .ne. ' ' ) empty = .false.
      end do
      if ( empty ) Header(1:28) = ' (No title provided by user)'
      write(15,'(A)') Header(1:72)
      write(15,'(A)') Header(73:144)
      call Get_iScalar('Unique atoms',nAtoms)
!      Call Get_nAtoms_All(nAtoms)
      write(15,'(A,I4)') 'number of atoms: ',nAtoms
      allocate( coord(3*nAtoms) )
      allocate( AtomLbl(nAtoms) )
      allocate( BasfnLbl(nBas) )                              ! see comment 1
      allocate( zNuc(nAtoms) )
      allocate( nCntr(nAtoms,7) )
      allocate ( CoM(3))
!      Call Get_Coord_All(coord,nAtoms)
      call Get_dArray('Unique Coordinates',Coord,3*nAtoms)
      Call Get_cArray('Unique Atom Names',AtomLbl,LblL*nAtoms)
      Call Get_cArray('Unique Basis Name',BasfnLbl,nBas*LblL8)
      Call Get_dArray('Nuclear charge',zNuc,nAtoms)
      call Get_dArray('Center of Mass',CoM,3)
      nCntr = 0
      iAtom = 1
      if (BasfnLbl(1)(9:9).eq.'s') nCntr(1,1)=1
      if (BasfnLbl(1)(9:9).eq.'p') nCntr(1,2)=1
      if (BasfnLbl(1)(9:9).eq.'d') nCntr(1,3)=1
      if (BasfnLbl(1)(9:9).eq.'f') nCntr(1,4)=1
      if (BasfnLbl(1)(9:9).eq.'g') nCntr(1,5)=1
      if (BasfnLbl(1)(9:9).eq.'h') nCntr(1,6)=1
      if (BasfnLbl(1)(9:9).eq.'i') nCntr(1,7)=1
      do j = 2, nBas
        if ( BasfnLbl(j)(1:6) .ne. BasfnLbl(j-1)(1:6) ) 
     &                                  iAtom = iAtom + 1   ! next atom
        if (BasfnLbl(j)(9:9).eq.'s') nCntr(iAtom,1)=nCntr(iAtom,1)+1
        if (BasfnLbl(j)(9:9).eq.'p') nCntr(iAtom,2)=nCntr(iAtom,2)+1
        if (BasfnLbl(j)(9:9).eq.'d') nCntr(iAtom,3)=nCntr(iAtom,3)+1
        if (BasfnLbl(j)(9:9).eq.'f') nCntr(iAtom,4)=nCntr(iAtom,4)+1
        if (BasfnLbl(j)(9:9).eq.'g') nCntr(iAtom,5)=nCntr(iAtom,5)+1
        if (BasfnLbl(j)(9:9).eq.'h') nCntr(iAtom,6)=nCntr(iAtom,6)+1
        if (BasfnLbl(j)(9:9).eq.'i') nCntr(iAtom,7)=nCntr(iAtom,7)+1
      end do
      iCounter = 1
      lAO = 's  p  d  f  g  h  i'
      write(15,'(6x,A,10x,2A,5x,A)')
     & 'Atom','x             y             z',
     &         '          Znuc',lAO
      do iAtom = 1, nAtoms
        write(15,201)iAtom,AtomLbl(iAtom),(coord(k),k=iCounter,
     &         iCounter+2),zNuc(iAtom),(nCntr(iAtom,l)/(2*(l-1)+1),
     &         l=1,7)
        iCounter = iCounter + 3
      end do
      write(15,'(A18,3F14.8)')'Center of Mass:',(CoM(k),k=1,3)
      if (print_level .ge. 20) then
        write(*,'(A18,3F20.14)')'Center of Mass:',(CoM(k),k=1,3)
      end if
 201  format (I4,2x,A6,3F14.8,2x,F7.2,3x,7I3)
      end

      function scal(i,j,k,l)
      integer   :: i,j,k,l
      real (kind = 8)      :: scal
      scal = 1.0
      if ( i .eq. j ) scal = scal * 0.5
      if ( k .eq. l ) scal = scal * 0.5
      if ( ( i. eq. k .and. j .eq. l )
     &     .or.
     &   ( i .eq. l .and. j .eq. k ) ) scal = scal * 0.5
      return 
      end 

! Comment 1: The number of s, p, d etc. functions per atom is not known outside Molcas, this info is not
! written to any file (ONEINT, RUNFILE, TRAINT, JOBIPH). Therefore we have to determine it in an indirect
! way by comparing the basis set labels. If this interface is integrated in Molcas, the info is directly
! available through common blocks.


      subroutine read_input(Project,print_level,write_labels,nTraRec,
     &                                             almostZero,combas)
      implicit none

      integer, parameter                   :: nKeys = 7
      integer                              :: iKey,jj,iFrag,nFrags
      character (len = 80)                 :: combas
      integer                              :: nTraRec
      integer                              :: print_level
      logical                              :: write_labels
      logical                              :: all_ok=.true.
      logical, dimension(nKeys)            :: hit = .false.
      character (len = 80)                 :: Project 
      character (len=4)                    :: key
      character (len=4), dimension(nKeys)  :: keyword
      character (len=132)                  :: line
      real (kind=8)                        :: almostZero,filesize
      character (len=3)                    :: lFrag

      data keyword /'PROJ','FILE','PRIN','WRIT','SMAL','FRAG','LABE'/

* * Keywords * * * * 
*
*      PROJect         : prefix for all filename generated by rdtraint
*      FILEsize        : Maximum size in MBytes (approx) of the 2-el. integral files
*      PRINT level     : x < 10 , standard
*                        10 =< x < 20  extra (debug) info, e.g. overal AO basis and 1-el. integrals
*                        x >= 20 all integrals are printed
*      WRITe labels    : Integral labels will be written on the 2-el. integral file(s)
*                      : Default is not to write the labels
*      SMALl integrals : Threshold for considering an integral small,
*                        for info only (all integrals are written to file)
*
*********************

* defaults
      Project      = project
      filesize     = 2000           ! 2000 MByte (Approx)
      print_level  = 1
      write_labels = .false.
      almostZero   = 1.0e-10
       

      do while (all_ok)
        read(5,*,iostat=jj) line
        key = adjustl(line)
        call capitalize(key)
        do iKey = 1, nKeys
          if ( key .eq. keyword(iKey) ) hit(iKey) = .true.
        end do
        if (  jj .lt. 0 ) all_ok = .false.
      end do

      combas=""
      do iKey = 1, nKeys
        if ( hit(iKey) ) then
          select case(iKey)
            case(1)
              call locate('PROJ')
              read(*,*) project
              project = trim(project)
            case(2)
              call locate('FILE')
              read(*,*) filesize 
            case(3)
              call locate('PRIN')
              read(*,*) print_level
            case(4)
              call locate('WRIT')
              write_labels = .true.
            case(5)
              call locate('SMAL')
              read(*,*) almostZero
            case(6)
              call locate('FRAG')
              read(*,*) nFrags
            case(7)
              call locate('LABE')
              do iFrag=1,nFrags
                read(*,*) lFrag
                combas=trim(combas)//trim(lFrag)
              enddo
          end select
        end if
      end do
      if ( print_level .le. 0 ) print_level = 1
      if ( almostZero .lt. 0 ) almostZero = -almostZero
      filesize = filesize  * 1.0e6
      if ( write_labels ) then
        nTraRec = int(filesize / (2*8*9600) )
      else
        nTraRec = int(filesize / (8*9600) )
      endif  
      return
      end subroutine read_input        



      subroutine locate(string)
      implicit none
      character(4)   ::  string,string2
      character(132) ::  line
      rewind(5)
 40   read(5,*) line
      string2=adjustl(line)
      call capitalize(string2)
      if (string2.ne.string) goto 40
      return
      end subroutine locate


      subroutine capitalize(string)
      implicit none
      integer      :: i
      character(*) string

      do i = 1, len(string)
        if (ichar(string(i:i)).gt.96) then
          string(i:i) = char(ichar(string(i:i))-32)
        endif
      end do
      return
      end subroutine capitalize 
