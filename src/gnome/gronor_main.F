      subroutine gronor_main()

!     initialization of the calculation

!     reading a root name from the command line
!     the root name will be used to generate all other
!     filenames associated with the calculation

!     $(root).inp is the input file
!     $(root).out is the output file
!     $(root).sym contains the symmetry of MOs for different sets,
!                 coordinates, basis set. This is the old fort.7 file
!     $(root)_nnn.civ contain the CI vectors, one for every nnn=1,mstates
!                 These files are generated by GAMES-UK (I7,F25.14,6x,10(I2,X))
!                 where the first line contains #det #nact #inact
!     $(root)_nnn.vec contain the vectors, one for every nnn=1,mstates
!                 These files are generated by GAMESS-UK and then modified
!                 using gam2sym2.x to get the same format as GNOME (4F18.14)

!     Need to specify the format and content of these files,
!     as well as the third party codes that generate them

      use mpi
      use inp
      use cidef
      use cidist
      use gnome_parameters
      use gnome_data
      use gnome_integrals

      implicit none
!tps#include 'mpif.h'
      integer (kind=4) :: ierr
      integer :: iarg,i,j,idum(51),k,l,len,nn,ifac
Coen Oct17_19: idum is used for two different purposes (ugly),
C              let's avoid that
      integer,allocatable :: iocc_tmp(:)
      integer :: maxci, maxvec, maxnact
      integer :: mactb, maxcib, mdum, node
      real (kind=8) :: sdum,ctime,wtime,rmat(2),rmatt(2),rdum(3)
      character (len=255) :: string, filnam, card, item

      real(kind=8), external :: timer_wall_total
      
      integer :: l1
      logical :: osame

      integer :: getcpucount
      external :: getcpucount

      integer :: im,is,ie,km,ks,ke,lm,ls,le,nm,ns,ne,n,kl,ll,nl
      integer :: nmax,kbloc

      integer :: igr, numone, numtwo
      integer (kind=4) :: new,newme,newgrp,newrnk
      integer :: maxcib1
      character (len=255) :: opt_inp
      real (kind=8), allocatable :: tc(:)

      integer :: maxgrp

#ifdef USE_POSIXF
      integer*4 len4,ierr4
#endif

      call timer_init()

      call timer_start(99)
      call timer_start(1)
      call timer_start(2)

      bias=0.0d0
      deta=0.0d0

      if(me.eq.master) then

       user='                  '
       host='                  '
       date='                  '
       time='                  '
       cwd='                   '

#ifdef USE_POSIXF
       call pxfgetlogin(user,len4,ierr4)
#else
       call getlog(user)
       call hostnm(host)
       call swatch(date,time)
       call getcwd(cwd)
#endif

!     Read a single string argument 'root' from the command line, that
!     will be used to generate all other files used to read and write
!     data associated with this calculation

!     input file: filinp with logical file number lfninp
!     output file: filout with logical file number lfnout
!     symmetry file: filsym with logical file number lfnsym
!     what is on?: filciv with logical file number lfnciv
!     what is on?: filvec with logical file number lfnvec

       iarg=0
       call getarg(iarg,command)
       iarg=1
       call getarg(iarg,string)

       root=string(1:inp_strlen(string))
       if(index(string,'_').gt.0) root=string(1:index(string,'_')-1)
       filinp=string(1:inp_strlen(string))//'.inp'
       lfninp=5
       filout=string(1:inp_strlen(string))//'.out'
       lfnout=16
       filsym=root(1:inp_strlen(root))//'.sym'
       lfnsym=7
       lfnciv=9
       lfnvec=10
       filint=root(1:inp_strlen(root))//'.int'
       filone=root(1:inp_strlen(root))//'.one'
       lfnint=11
       lfnone=11
       lfntwo=12
       lfndbg=13
       filpro=string(1:inp_strlen(string))//'.pro'
       lfnpro=14
       fildat=string(1:inp_strlen(string))//'.dat'
       lfndat=15
       filday=string(1:inp_strlen(string))//'.day'
       lfnday=18
       lfnf74=74
       filf74=string(1:inp_strlen(string))//'.f74'
       lfnf75=75
       filf75=string(1:inp_strlen(string))//'.f75'

       open(unit=lfnout,file=filout(1:inp_strlen(filout)),
     &  form='formatted',status='unknown',err=996)

       open(unit=lfnpro,file=filpro(1:inp_strlen(filpro)),
     &  form='formatted',status='unknown',err=996)

       open(unit=lfnday,file=filday(1:inp_strlen(filday)),
     &  form='formatted',status='unknown',err=996)

       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Start of job'
  702  format(a8,2x,a8,f12.3,a)
       flush(lfnday)
       call timer_start(99)
           
       write(lfnout,600)
  600  format(/,
     &  ' GronOR: Non-Orthogonal Configuration Interaction program',//,
     &  9x,'T. P. Straatsma',/,
     &  9x,'National Center for Computational Sciences',/,
     &  9x,'Oak Ridge National Laboratory',/,
     &  9x,'Oak Ridge, Tennessee, USA',//,
     &  9x,'C. de Graaf',/,
     &  9x,'Quantum Chemistry Group',/,
     &  9x,'University Rovira i Virgili',/,
     &  9x,'Tarragona, Spain',//,
     &  9x,'R. W. A. Havenith and R. K. Kathir',/,
     &  9x,'Department of Theoretical Chemistry',/,
     &  9x,'University of Groningen',/,
     &  9x,'Groningen, the Netherlands',//,
     &  9x,'Based on GNOME written by R. Broer-Braam, ',
     &  'J. Th. van Montfort, and B. Vunderink',//,
     &  9x,'Please cite the following reference when publishing ',
     &  'results obtained using GronOR:',//,
     &  9x,'T. P. Straatsma, R. Broer, S. Faraji, R. W. A. Havenith,',
     &  'L. E. Aguilar Suarez,',/,
     &  9x,'R. K. Kathir, M. Wibowo,and C.de Graaf',/,
     &  9x,'"GronOR: Massively parallel and GPU-accelerated ',
     &  'non-orthogonal configuration ',/,
     &  9x,'interaction for large molecular systems"',/,
     &  9x,'Journal of Chemical Physics, 152 (2020), ',
     &  'https://doi.org/10.1063/1.5141358',/)

       write(lfnout,601) trim(user),trim(host),date(1:8),time(1:8),
     &  trim(command),trim(cwd),filinp(1:inp_strlen(filinp)),
     &  filout(1:inp_strlen(filout)),filsym(1:inp_strlen(filsym)),
     &  filint(1:inp_strlen(filint)),
     &  root(1:inp_strlen(root)),root(1:inp_strlen(root)),
     &  getcpucount(),numdev,np,num_threads
       if(numdev.gt.0) write(lfnout,602) memfre,memtot
 601   format(//,
     &  ' User',t50,a,/,
     &  ' Host',t50,a,/,
     &  ' Date',t50,a,/,
     &  ' Time',t50,a,//,
     &  ' Command argument',t50,a,/,
     &  ' Current working directory',t50,a,//,
     &  ' Input filename is  ',t50,a,/,
     &  ' Output filename is  ',t50,a,//,
     &  ' Symmetry filename is  ',t50,a,/,
     &  ' Integral filename is  ',t50,a,//,
     &  ' CI vector filename(s) are  ',t50,a,'_nnn.civ',/,
     &  ' MO vector filename(s) are  ',t50,a,'_nnn.vec',//,
     &  ' CPU count',t50,i10,/,
     &  ' Number of NVIDIA devices',t50,i10,/,
     &  ' Number of MPI ranks',t50,i10,/,
     &  ' Number of OPENMP threads',t50,i10,/)
 602   format(' Available memory on device',t40,i20,/,
     & ' Total memory on device',t40,i20,/)

!     Read from the input file

!     npg:     number of processes per group (default is 1)
!     nmol:    number of molecules
!     mstates: number of molecular states
!     nbase:   number of many-electron base (?)

!     and use these to allocate

!     ncombv(nmol,nbase): the combination
!     nbasm(mstates):    number of one-electron basis functions per monomer/state
!     inactm(mstates):   number of inactive orbitals per monomer/state
!     idetm(mstates):    number of determinants per monomer/state

!     Set defaults

       npg=0
       mgr=0
       nmol=0
       mstates=0
       iload=1
       ibatch=1
       itest=0
       intadd=0
       naccel=-1
       nummps=1
       numomp=1
#ifdef _OPENACC
       naccel=0
#endif
       nqcp=1
       ipr=-1
       itim=-1
       ipro=-1
       iday=10
       idbg=0
       nspin=0
       mpibuf=168435456
       thresh=1.0d-10
       thresh_CI=1.0d-10
       thresh_SIN=1.0d-12

       open(unit=lfninp,file=filinp,form='formatted',status='old',
     &  err=999)

 1     continue

       if(inp_read()) then

 2     continue

       if(.not.inp_a(item)) goto 1

 3     continue

       if(inp_compare(.false.,'Groups',item)) then
       if(.not.inp_i(npg)) call errquit()
       goto 2
       endif

       if(inp_compare(.false.,'Size',item)) then
       if(.not.inp_i(mgr)) call errquit()
       if(npg.eq.0) npg=(np-1)/mgr
       if(np.lt.mgr+1) then
        write(*,'(a,i5,a,i5,a)') 'Error: Size specified (',mgr,
     &   ') cannot be supported by available ranks (',np,')'
        call errquit()
       endif
       goto 2
       endif

       if(inp_compare(.false.,'Molecules',item)) then
        if(.not.inp_i(nmol)) call errquit()
        if(.not.inp_i(nbase)) call errquit()
        allocate(ncombv(nmol,nbase))
        do i=1,nmol
         if(.not.inp_read()) call errquit()
         do j=1,nbase
          if(.not.inp_i(ncombv(i,j))) call errquit()
          if(ncombv(i,j).eq.0) ncombv(i,j)=9
         enddo
        enddo
        goto 2
       endif

       if(inp_compare(.false.,'States',item)) then
        if(.not.inp_i(mstates)) mstates=1
        goto 2
       endif

       if(inp_compare(.false.,'Spin',item)) then
        if(.not.inp_i(nspin)) call errquit()
        goto 2
       endif

       if(inp_compare(.false.,'Threshold',item)) then
        if(.not.inp_f(thresh)) call errquit()
        thresh_CI=thresh
        goto 2
       endif

       if(inp_compare(.false.,'Thresh_CI',item)) then
        if(.not.inp_f(thresh_CI)) thresh_CI=1.0d-10
        goto 2
       endif
 
       if(inp_compare(.false.,'Thresh_SIN',item)) then
        if(.not.inp_f(thresh_SIN)) thresh_SIN=1.0d-12
        goto 2
       endif

       if(inp_compare(.false.,'Load',item)) then
        if(.not.inp_i(iload)) iload=1
        goto 2
       endif

       if(inp_compare(.false.,'Range',item)) then
        if(.not.inp_i(ibatch)) ibatch=1
        goto 2
       endif

       if(inp_compare(.false.,'Batch',item)) then
        if(.not.inp_i(ibatch)) ibatch=1
        goto 2
       endif

       if(inp_compare(.false.,'Print',item)) then
        if(.not.inp_i(ipr)) ipr=1
        goto 2
       endif

       if(inp_compare(.false.,'Timings',item)) then
        if(.not.inp_i(itim)) itim=1
        goto 2
       endif

       if(inp_compare(.false.,'Debug',item)) then
        if(.not.inp_i(idbg)) idbg=1
        goto 2
       endif

       if(inp_compare(.false.,'Dayfile',item)) then
        if(.not.inp_i(iday)) iday=10
        goto 2
       endif

       if(inp_compare(.false.,'Progress',item)) then
        if(.not.inp_i(ipro)) ipro=1
        goto 2
       endif

       if(inp_compare(.false.,'Test',item)) then
        if(.not.inp_i(itest)) itest=0
        goto 2
       endif

       if(inp_compare(.false.,'IntAdd',item)) then
        if(.not.inp_i(intadd)) intadd=0
        goto 2
       endif

       if(inp_compare(.false.,'Maxcib',item)) then
        if(.not.inp_i(inpcib)) inpcib=0
        goto 2
       endif

       if(inp_compare(.false.,'MPIbuffer',item)) then
        if(.not.inp_i(mpibuf)) call errquit()
        goto 2
       endif

       if(inp_compare(.false.,'Accelerate',item)) then
        if(.not.inp_i(naccel)) naccel=0
        goto 2
       endif

       if(inp_compare(.false.,'MPS',item)) then
        if(.not.inp_i(nummps)) nummps=1
        goto 2
       endif

       if(inp_compare(.false.,'OMP',item)) then
        if(.not.inp_i(numomp)) numomp=1
        goto 2
       endif

       if(inp_compare(.false.,'QCprogram',item)) then
        if(.not.inp_a(opt_inp)) opt_inp='symol'
        if(inp_compare(.false.,'symol',opt_inp)) then
         nqcp=1
        else if(inp_compare(.false.,'gamess',opt_inp)) then
         nqcp=2
        else if(inp_compare(.false.,'molcas',opt_inp)) then
         nqcp=3
        end if
        goto 2
       endif

       goto 1
       endif

       if(mgr.eq.0) then
        if(npg.eq.0) call errquit()
        mgr=(np-1)/npg
       endif

       call gronor_number_integrals(numone,numtwo)
Coen: Warning, numone and numtwo are read from a dummy entry. The real
C     number of two electron integrals is on the next record of the 1-el
C     integral file. Now, they always take the values 8421 and -1. 
C     When npg = 0, something very strange will come out (I guess).
       if(npg.eq.0) then
        npg=numtwo/intsrnk
        if(mod(numtwo,intsrnk).gt.0) npg=npg+1
       endif

       if(mgr.eq.0) then
        if(iload.eq.0) mgr=np/npg
        if(iload.eq.1) mgr=(np-1)/npg
       else
        if(npg*mgr+1.gt.np) then
         write(lfnout,983)
 983     format(' Requested number of ranks exceeds available')
         call errquit()
        endif
       endif

       allocate(nbasm(mstates))
       allocate(nactm(mstates))
       allocate(inactm(mstates))
       allocate(idetm(mstates))

       iocc(1)=1
       iocc(2)=2
       iord(1)=0
       iord(2)=0
       indx(1)=0
       indx(2)=0
       icalc=0
       ins2=0
       ipvec=0
       idipole=0
       itp4=0
       ione=0
       bias=0.0d0
       corres=.false.

       close(unit=lfninp)

       if(iload.eq.0) write(lfnout,622)
 622   format(' No load balancing',/)
       if(iload.eq.1) write(lfnout,619) ibatch
 619   format(' Task-based load balancing, batch size',t50,i10,/)
       write(lfnout,623) thresh_CI, thresh_SIN
 623   format(' Threshold for CI coefficients',t50,1pe12.3,/,
     &  ' Threshold for ISING',t50,1pe12.3,/)
       write(lfnout,620) mgr
 620   format(' Integrals divided over tasks number of ranks',t50,i10,/)

       if(iload.eq.1.and.mgr.gt.1) write(lfnout,621) (np-1)/mgr
 621   format(' Parallelism for matrix elements',t50,i10,/)

       write(lfnout,603) nmol,mstates,nbase
 603   format(
     &  ' Number of molecules (nmol)',t50,i10,/,
     &  ' Number of molecular states (mstates)',t50,i10,/,
     &  ' Number of many-electron states (nbase)',t50,i10,/)

       maxci=0
       maxvec=0
       maxnact=0

       if(ipr.ge.1) write(lfnout,604)
 604   format(/,' Dimensions',//,
     &  '  istate   ndetm   nactm  ninatm   nbasm   files',/)

       do i=1,mstates
        write(filciv,200) root(1:inp_strlen(root)),i
 200    format(a,'_',i3.3,'.civ')
        len=inp_strlen(filciv)
        open(unit=lfnciv,file=filciv(1:len),form='formatted',
     &  status='old',err=998)
        read(lfnciv,*) idetm(i),nactm(i),inactm(i)
        close(unit=lfnciv)
        write(filvec,201) root(1:inp_strlen(root)),i
 201    format(a,'_',i3.3,'.vec')
        len=inp_strlen(filvec)
        open(unit=lfnvec,file=filvec(1:len),form='formatted',
     &  status='old',err=998)
        read(lfnvec,*) nbasm(i)
        close(unit=lfnvec)
        maxci=max(maxci,idetm(i))
        maxvec=max(maxvec,nbasm(i))
        maxnact=max(maxnact,nactm(i))
        if(ipr.ge.1)
     &   write(lfnout,605) i,idetm(i),nactm(i),inactm(i),nbasm(i),
     &   filciv(1:inp_strlen(filciv)),filvec(1:inp_strlen(filvec))
 605    format(5i8,3x,a,', ',/,43x,a)
       enddo

       if(ipr.ge.1) write(lfnout,606) maxci,maxnact,maxvec
 606   format(8x,'  ------  ------',8x,'  ------',/,
     &  '    max:',i8,i8,8x,i8)

       allocate(civm(maxci,mstates))
       allocate(vecsm(maxvec,maxvec,mstates))
       allocate(ioccm(maxnact,maxci,mstates))

       write(lfnout,613) (i,i=1,nbase)
 613   format(/,' Molecular states included in this calculation',//,
     & ' State        : ',20i4)
       write(lfnout,624)
 624   format(/)
       do i=1,nmol
        write(lfnout,617) i,(ncombv(i,j),j=1,nbase)
 617    format(' Molecule',i4,' : ',20i4)
       enddo

       if(ipr.ge.2) write(lfnout,607)
 607   format(//,'  istate   idetm           ci coefficient')

Coen Oct17_19: changed idum for iocc_tmp, idum is used later for
C              something completely different.
      allocate( iocc_tmp(maxnact) )
      do i=1,mstates
       iocc_tmp = 0
       write(filciv,200) root(1:inp_strlen(root)),i
       len=inp_strlen(filciv)
       open(unit=lfnciv,file=filciv(1:len),form='formatted',
     & status='old',err=998)
       read(lfnciv,*)
       do j=1,idetm(i)
        read(lfnciv,1002) nn,civm(j,i),(iocc_tmp(k),k=1,nactm(i))
 1002   format(i7,f25.14,6x,20(i2,x))
        if(j.eq.1) then
        write(lfnout,608) i,nn,civm(j,i),(iocc_tmp(k),k=1,nactm(i))
 608    format(/,2i8,f25.14,6x,20(i2.2,1x))
        else
        if(ipr.ge.2)
     &   write(lfnout,609) nn,civm(j,i),(iocc_tmp(k),k=1,nactm(i))
 609    format(8x,i8,f25.14,6x,20(i2.2,1x))
        endif
        do k=1,nactm(i)
         if(iocc_tmp(k).eq.11) then
          ioccm(k,j,i)=2
         elseif(iocc_tmp(k).eq.1) then
          ioccm(k,j,i)=-1
         elseif(iocc_tmp(k).eq.10) then
          ioccm(k,j,i)=1
         elseif(iocc_tmp(k).eq.0) then
          ioccm(k,j,i)=0
         else
          print *,(iocc_tmp(l),l=1,nactm(i))
          stop 'weird occupation'
         endif
        enddo
       enddo
       close(unit=lfnciv)

       write(filvec,201) root(1:inp_strlen(root)),i
       len=inp_strlen(filvec)
       open(unit=lfnvec,file=filvec(1:len),form='formatted',
     & status='old',err=998)
       read(lfnvec,*)
       if(ipr.ge.4) then
        write(lfnout,2002) filvec(1:len),nbasm(i)
 2002   format(/,' Vector File ',a,//,
     &  ' Number of basis functions ',i8,/)
       endif
       do j=1,nbasm(i)
        read(lfnvec,1003) (vecsm(k,j,i),k=1,nbasm(i))
 1003   format(4F18.14)
        if(ipr.ge.4) then
         write(lfnout,2003) j,(vecsm(k,j,i),k=1,nbasm(i))
 2003    format(i5,5f25.14,/,(5x,5f25.14))
        endif
       enddo
       close(unit=lfnvec)
       flush(lfnout)
      enddo
      deallocate (iocc_tmp)
      write(filsym,202) root(1:inp_strlen(root))
 202  format(a,'.sym')
      len=inp_strlen(filsym)
      open(unit=lfnsym,file=filsym(1:len),form='formatted',
     & status='old',err=995)

      if(ipr.ge.3) write(lfnout,610) filsym(1:inp_strlen(filsym))
 610  format(/,' System information read from ',a,/)

Coen: remove SYMOL from the list of QC programs
C         if (nqcp.eq.1) then
C      call gronor_gnome_symmetry_input(lfnsym,lfnout,ipr)
C      elseif (nqcp.eq.2) then
      if ( nqcp .eq. 2 ) then
        call gronor_gnome_symmetry_input_gamess(lfnsym,lfnout,ipr)
      elseif (nqcp.eq.3) then
        call gronor_gnome_molcas_input(lfnsym,lfnout,ipr)       ! OpenMolcas
      endif
      close(unit=lfnsym)

      else                    ! belonging to "if(inp_read()) then" (I guess)
       lfnout=6
       write(filout,650) me
 650   format('gronor_',i5.5,'.dbg')
       if(ipr.ge.10) then
        open(unit=lfnout,file=filout(1:inp_strlen(filout)),
     &   form='formatted',status='unknown',err=996)
       endif
      endif

!     Distribute input data to all processes

      if(np.gt.1) then

       if(me.eq.master) then
        idum(1)=nmol
        idum(2)=mstates
        idum(3)=nbase
        idum(4)=maxci
        idum(5)=maxvec
        idum(6)=maxnact
        idum(7)=iocc(1)
        idum(8)=iocc(2)
        idum(9)=iord(1)
        idum(10)=iord(2)
        idum(11)=indx(1)
        idum(12)=indx(2)
        idum(13)=icalc
        idum(14)=ipr
        idum(15)=ins2
        idum(16)=ipvec
        idum(17)=itp4
        idum(18)=ione
        idum(19)=0
        if(corres) idum(19)=1
        idum(20)=npg
        idum(21)=nnucl
        idum(22)=nbas
        idum(23)=iload
        idum(24)=ibatch
        idum(25)=mgr
        idum(26)=itest
        idum(27)=naccel
        idum(28)=inpcib
        idum(29)=ipro
        idum(30)=intadd
        idum(31)=mpibuf
        idum(32)=idbg
        idum(33)=nummps
        idum(34)=numomp
        idum(35)=itim
        idum(36)=0

        rdum(1)=thresh
        rdum(2)=thresh_CI
        rdum(3)=thresh_SIN
       endif

       call MPI_Bcast(idum,36,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
       call MPI_Bcast(rdum,3,MPI_REAL8,master,MPI_COMM_WORLD,ierr)

       nmol   =idum(1)
       mstates=idum(2)
       nbase  =idum(3)
       maxci  =idum(4)
       maxvec =idum(5)
       maxnact=idum(6)
       iocc(1)=idum(7)
       iocc(2)=idum(8)
       iord(1)=idum(9)
       iord(2)=idum(10)
       indx(1)=idum(11)
       indx(2)=idum(12)
       icalc  =idum(13)
       ipr    =idum(14)
       ins2   =idum(15)
       ipvec  =idum(16)
       itp4   =idum(17)
       ione   =idum(18)
       corres =idum(19).eq.1
       npg    =idum(20)
       nnucl  =idum(21)
       nbas   =idum(22)
       iload  =idum(23)
       ibatch =idum(24)
       mgr    =idum(25)
       itest  =idum(26)
       naccel =idum(27)
       inpcib =idum(28)
       ipro   =idum(29)
       intadd =idum(30)
       mpibuf =idum(31)
       idbg   =idum(32)
       nummps =idum(33)
       numomp =idum(34)
       itim   =idum(35)

       thresh=rdum(1)
       thresh_CI=rdum(2)
       thresh_SIN=rdum(3)

      endif

#ifdef _OPENMP
      if(numomp.gt.0) num_threads=numomp
      if(num_threads.gt.0) call omp_set_num_threads(num_threads)
#endif

      lfnone=11
      lfntwo=12
      lfndbg=13
      if(idbg.gt.0) then
       write(fildbg,1300) me
 1300  format('GronOR_',i5.5,'.dbg ')
       open(unit=lfndbg,file=fildbg(1:inp_strlen(fildbg)),
     & form='formatted',status='unknown',err=996)
      endif

      nacc0=naccel
      nacc1=naccel

      if(me.ne.master) then
        nmol   =idum(1)
        mstates=idum(2)
        nbase  =idum(3)
        maxci  =idum(4)
        maxvec =idum(5)
        maxnact=idum(6)
  
        allocate(ncombv(nmol,nbase))
        allocate(nbasm(mstates))
        allocate(nactm(mstates))
        allocate(inactm(mstates))
        allocate(idetm(mstates))
        allocate(civm(maxci,mstates))
        allocate(vecsm(maxvec,maxvec,mstates))
        allocate(ioccm(maxnact,maxci,mstates))
  
        iocc(1)=idum(7)
        iocc(2)=idum(8)
        iord(1)=idum(9)
        iord(2)=idum(10)
        indx(1)=idum(11)
        indx(2)=idum(12)
        icalc  =idum(13)
        ipr    =idum(14)
        ins2   =idum(15)
        ipvec  =idum(16)
        itp4   =idum(17)
        ione   =idum(18)
        corres =idum(19).eq.1
      endif
      if(np.gt.0) then
        call MPI_Bcast(nqcp,1,MPI_INTEGER8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(civm,maxci*mstates,MPI_REAL8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(vecsm,maxvec*maxvec*mstates,MPI_REAL8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(ioccm,maxnact*maxci*mstates,MPI_INTEGER8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(ncombv,nmol*nbase,MPI_INTEGER8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(nbasm,mstates,MPI_INTEGER8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(nactm,mstates,MPI_INTEGER8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(inactm,mstates,MPI_INTEGER8,master,
     &   MPI_COMM_WORLD,ierr)
        call MPI_Bcast(idetm,mstates,MPI_INTEGER8,master,
     &   MPI_COMM_WORLD,ierr)
        endif

      nbasis=0
      mactb=0
      do i=1,nmol
       nbasis=nbasis+nbasm(ncombv(i,1))
       mactb=mactb+nactm(ncombv(i,1))
      enddo

      maxcib=0
      do i=1,nbase
         maxcib1=1
         do j=1,nmol
            maxcib1=maxcib1*idetm(ncombv(j,i))
         enddo
         maxcib=max(maxcib,maxcib1)
      enddo
      maxcib=6*maxcib
      if (me.eq.master) then
       write(lfnout,629) maxcib
 629   format(/,' Recommended value of maxcib is ',i10)
      endif
      if(inpcib.ne.0) maxcib=inpcib

      allocate(civb(maxcib,nbase))
      allocate(vecsb(nbasis,nbasis,nbase))
      allocate(ioccb(maxcib,nbase))
      allocate(inactb(nbase))
      allocate(nactb(nbase))
      allocate(idetb(nbase))

      ngr=(np-1)/mgr

      allocate(ranks_heads(ngr+1))

      master=np-1

      node=map2(1,4)
      j=nummps*map2(1,1)
      do i=1,np
       map2(i,2)=numomp
       if(map2(i,4).eq.node) then
        if(j.gt.0) then
         map2(i,5)=map2(i,1)
         if(naccel.lt.0) map2(i,5)=-map2(i,2)
         j=j-1
        else
         map2(i,5)=-map2(i,2)
        endif
       else
        node=map2(i,4)
        j=nummps*map2(i,1)
        if(j.gt.0) then
         map2(i,5)=map2(i,1)
         if(naccel.lt.0) map2(i,5)=-map2(i,2)
         j=j-1
        else
         map2(i,5)=-map2(i,2)
        endif
       endif
       if(i-1.eq.master) map2(i,5)=0
      enddo

      if(me.eq.master) then
       numacc=0
       numnon=0
       do i=1,np
        if(map2(i,5).gt.0) numacc=numacc+1
        if(map2(i,5).lt.0) numnon=numnon+1
       enddo
       numacc=numacc/mgr
       numnon=numnon/mgr
       maxgrp=numacc+numnon
      endif
      call MPI_Bcast(maxgrp,1,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      allocate(thisgroup(mgr+1))
      allocate(allgroups(maxgrp+1,mgr+1))
      allocate(allheads(maxgrp+1))
      if(me.eq.master) then
       numgrp=0
       igr=0
       do i=1,np
        if(map2(i,5).gt.0) then
         if(igr.eq.0) numgrp=numgrp+1
         igr=igr+1
         allgroups(numgrp,1)=map2(i,5)
         allgroups(numgrp,igr+1)=i-1
         if(igr.eq.mgr) igr=0
        endif
       enddo
       if(igr.ne.0.and.numgrp.gt.0) numgrp=numgrp-1
       igr=0
       do i=1,np
        if(map2(i,5).lt.0) then
         if(igr.eq.0) numgrp=numgrp+1
         igr=igr+1
         allgroups(numgrp,1)=map2(i,5)
         allgroups(numgrp,igr+1)=i-1
         if(igr.eq.mgr) igr=0
        endif
       enddo
       if(igr.ne.0.and.numgrp.gt.0) numgrp=numgrp-1
       do i=1,numgrp
        allheads(i)=allgroups(i,2)
        do j=1,mgr
         map2(allgroups(i,j+1)+1,3)=i
        enddo
       enddo
       allheads(numgrp+1)=master
      endif
      call MPI_Bcast(numgrp,1,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(map2,5*np,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(allgroups,int((maxgrp+1)*(mgr+1),kind=4),
     & MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(allheads,int(maxgrp,kind=4),MPI_INTEGER8,master,
     & MPI_COMM_WORLD,ierr)
      if(numgrp.eq.0) then
       write(*,'(a)') 'Number of groups is zero'
       call errquit()
      endif
      do i=1,numgrp
       do j=1,mgr
        if(me.eq.allgroups(i,j+1)) then
         do k=1,mgr+1
          thisgroup(k)=allgroups(i,k)
         enddo
        endif
       enddo
      enddo

      if(me.ne.master) then
       iamhead=0
       if(me.eq.thisgroup(2)) iamhead=1
       myhead=thisgroup(2)
       numdev=thisgroup(1)
       if(numdev.lt.0) numdev=0
      else
       myhead=master
       numdev=0
      endif

      mygroup=0
      do i=1,numgrp
       ranks_heads(i)=allgroups(i,2)
       do j=1,mgr
        if(me.eq.allgroups(i,j+1)) mygroup=i
       enddo
      enddo
      ranks_heads(numgrp+1)=master

      new=-1

      call MPI_Comm_Group(MPI_COMM_WORLD,group_world,ierr)

      call MPI_Group_incl(group_world,int(numgrp+1,kind=4),ranks_heads,
     & group_heads,ierr)
      if(iamhead.eq.1) then
       call MPI_Group_Rank(group_heads,new,ierr)
      endif

      if(me.eq.master) then
       write(lfnout,630)
 630   format(//,' MPI Rank Assignments')
  635  format(/,' Accelerated Groups')
       k=1
       l=min(k+14,numacc)
       if(numacc.gt.0) then
        write(lfnout,635)
        do while (k.le.l)
         write(lfnout,634)
  634    format(/)
         write(lfnout,631) (j,j=k,l)
 631     format(10x,15i8)
         write(lfnout,632) (' ----',j=k,l)
 632     format(10x,15a8)
         do i=2,mgr+1
          write(lfnout,631) (allgroups(j,i),j=k,l)
         enddo
         k=l+1
         l=min(k+14,numacc)
        enddo
        write(lfnout,634)
       endif
       if(numnon.gt.0) then
        write(lfnout,633)
 633    format(/,' Non-Accelerated Groups')
        k=l+1
        l=min(k+14,numgrp)
        do while (k.le.l)
         write(lfnout,634)
         write(lfnout,631) (j,j=k,l)
         write(lfnout,632) (' ----',j=k,l)
         do i=2,mgr+1
          write(lfnout,631) (allgroups(j,i),j=k,l)
         enddo
         k=l+1
         l=min(k+14,numgrp)
        enddo
       endif
      endif

      iamacc=0
      iamactive=0
      if(me.eq.master) iamactive=1
      if(me.ne.master.and.thisgroup(1).gt.0) then
       do i=1,mgr
        if(me.eq.thisgroup(i+1)) iamacc=1
       enddo
      endif
      if(thisgroup(1).ne.0) then
       do i=1,mgr
        if(me.eq.thisgroup(i+1)) iamactive=1
       enddo
      endif

      if(me.eq.master) write(lfnout,611) nbase,nmol,nbasis
 611  format(//,' Dimensions',//,
     & ' Number of states (nbase)',t50,i16,/,
     & ' Number of molecules (nmol)', t50,i16,/,
     & ' Number of basis functions (nbasis)',t50,i16)

      do i=1,nbase

       if(me.eq.master.and.ipr.ge.5) write(lfnout,612) i
 612   format(/,' Base state',i4)
       call gronor_makebasestate
     & (lfnout,civm,vecsm,ioccm,nbasm,nactm,inactm,
     & idetm,maxci,maxvec,maxnact,mstates,civb(1,i),vecsb(1,1,i),
     & ioccb(1,i),inactb(i),nactb(i),idetb(i),maxcib,nbasis,mactb,
     & nmol,ncombv(1,i),nspin,thresh_CI)

      enddo

      if(me.eq.master) then
       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Base states generated'
       flush(lfnday)
       call timer_start(99)
      endif
       
      allocate(hbase(nbase,nbase),sbase(nbase,nbase))
      allocate(nsing(nbase,nbase,4))

!     Define the process groups

      if(npg.le.0) npg=1
      if(npg.gt.np) npg=np
      ngr=np/npg

      if(me.eq.master.and.ipr.ge.0) then
       write(lfnout,618) np,numgrp,mgr,np-numgrp*mgr-1
 618   format(/,' Process Distribution',//,
     &  ' Number of processes',t50,i16,/,
     &  ' Number of process groups',t50,i16,/,
     &  ' Number of processes per group',t50,i16,/,
     &  ' Number of idle processes',t50,i16,/)
      endif

      call timer_stop(2)
      call timer_start(3)

!     Read the integrals from lfnint

      call gronor_read_integrals()

      if(me.eq.master) then
       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Integrals read and distributed'
       flush(lfnday)
       call timer_start(99)
      endif
       
      if(me.eq.master.and.ipr.ge.0) then
       write(lfnout,614) nbas
       write(lfnout,615) int1
       write(lfnout,616) int2
 614   format(' Number of basisfunctions',t62,20i4)
 615   format(' Number of one-electron integrals',t50,i16)
 616   format(' Number of two-electron integrals',t50,i16)
      endif

      call timer_stop(3)
      call timer_start(4)

      if(me.eq.master.and.ipr.ge.5) then
       write(lfnout,628) nbase,nbase*(nbase+1)/2
 628   format(' Number of base states',t50,i16,/,                       &
     &        ' Number of base state elements',t50,i16)
      endif

      if(me.eq.master) flush(lfnout)

      if(me.eq.master) then
       allocate(numrecs(np))
       do i=1,np
        numrecs(i)=0
       enddo
      endif

      if(me.eq.master) then
       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Start Hamiltonian calculation'
       flush(lfnday)
       call timer_start(99)
      endif
       
      call timer_start(98)
      if(me.eq.master.and.iload.eq.1) then
       if(idbg.gt.0) then
        call swatch(date,time)
        write(lfndbg,'(a,1x,a,1x,a)') date(1:8),time(1:8),
     &      ' Calling GronOR_master'
        flush(lfndbg)
       endif
       call gronor_master()
      else
       if(idbg.gt.0) then
        call swatch(date,time)
        write(lfndbg,'(a,1x,a,1x,a,2i5)') date(1:8),time(1:8),
     &        ' iamactive, iamacc = ',iamactive,iamacc
        flush(lfndbg)
       endif
       if(iamactive.eq.1) then
        if(iamacc.eq.1) then
         if(idbg.gt.0) then
          call swatch(date,time)
          write(lfndbg,'(a,1x,a,1x,a,i12)') date(1:8),time(1:8),
     &        ' mint2= ',mint2
          flush(lfndbg)
         endif
ccccc!$acc data copyin(g(1:mint2),lab(1:4,1:mint2),t,v,ndxtv)
!$acc data copyin(g,lab,t,v,ndxtv)
         if(idbg.gt.0) then
          call swatch(date,time)
          write(lfndbg,'(a,1x,a,1x,a)') date(1:8),time(1:8),
     &        ' Calling GronOR_worker'
          flush(lfndbg)
         endif
         call gronor_worker()
!$acc end data
        else
         lwork=10
         allocate(work(lwork))
         call gronor_worker()
        endif
       endif
      endif
      call timer_stop(98)

      if(idbg.gt.0) then
       call swatch(date,time)
       write(lfndbg,'(a,1x,a,a,a)') date(1:8),time(1:8),
     & ' Closing ',trim(fildbg)
       flush(lfndbg)
       close(unit=lfndbg,status='keep')
      endif

      if(me.eq.master) then
       write(lfnout,674)
 674   format(//,' Hamiltonian Matrix unnormalised',/)
       open(unit=lfnf74,file=filf74,form='unformatted',status='unknown')
       write(74)nbase
       write(74)((hbase(j,i),i=1,j),j=1,nbase)
       write(74)((sbase(j,i),i=1,j),j=1,nbase)
       close(unit=lfnf74,status='keep')
       write(lfnout,671) (i,i=1,nbase)
       do j=1,nbase
        write(lfnout,672) j,(hbase(i,j),i=1,nbase)
       enddo
       write(lfnout,675)
 675   format(//,' Overlap Matrix unnormalised',/)
       write(lfnout,671) (i,i=1,nbase)
       do j=1,nbase
        write(lfnout,672) j,(sbase(i,j),i=1,nbase)
       enddo
      endif

      if(me.eq.master) then
       do i=1,nbase
        do j=1,i-1
         hbase(i,j)=(1.0d0/(dsqrt(sbase(i,i))*
     &    dsqrt(sbase(j,j))))*hbase(i,j)
         sbase(i,j)=(1.0d0/(dsqrt(sbase(i,i))*
     &    dsqrt(sbase(j,j))))*sbase(i,j)
         hbase(j,i)=hbase(i,j)
         sbase(j,i)=sbase(i,j)
        enddo
       enddo
       do i=1,nbase
        hbase(i,i)=(1.0d0/sbase(i,i))*hbase(i,i)
        sbase(i,i)=(1.0d0/sbase(i,i))*sbase(i,i)
       enddo
      endif

      if(me.eq.master) then
       write(lfnout,670)
       write(*,670)
 670   format(//,' Hamiltonian Matrix',/)
       write(*,671) (i,i=1,nbase)
       write(lfnout,671) (i,i=1,nbase)
 671   format(6x,7(6x,i8,6x))
       do j=1,nbase
        write(*,672) j,(hbase(i,j),i=1,nbase)
        write(lfnout,672) j,(hbase(i,j),i=1,nbase)
 672    format(i5,1x,7f20.10,/,(6x,7f20.10))
       enddo
       write(lfnout,673)
       write(*,673)
 673   format(//,' Overlap Matrix',/)
       write(lfnout,671) (i,i=1,nbase)
       write(*,671) (i,i=1,nbase)
       do j=1,nbase
        write(lfnout,672) j,(sbase(i,j),i=1,nbase)
        write(*,672) j,(sbase(i,j),i=1,nbase)
       enddo
       if(nbase.gt.1) then
        write(lfnout,676)
        write(*,676)
 676    format(//,' Electronic Couplings',/)
        write(lfnout,671) (i,i=1,nbase)
        write(*,671) (i,i=1,nbase)
        allocate(tc(nbase))
        do i=1,nbase
         do j=1,i-1
         tc(j)=hbase(i,j)-0.5d0*(hbase(i,i)+hbase(j,j))*sbase(i,j)/
     &      (1.0d0-sbase(i,j)*sbase(i,j))
         enddo
         if(i.eq.1) then
          write(lfnout,672) 1
          write(*,672) 1
         else
          write(lfnout,672) i,(tc(j),j=1,i-1)
          write(*,672) i,(tc(j),j=1,i-1)
         endif
        enddo
        deallocate(tc)
       endif
       open(unit=lfnf75,file=filf75,form='unformatted',status='unknown')
       write(75)nbase
       write(75)((hbase(j,i),i=1,j),j=1,nbase)
       write(75)((sbase(j,i),i=1,j),j=1,nbase)
       close(unit=lfnf75,status='keep')
      endif
      if(allocated(work)) deallocate(work)

      deallocate(t,v,ndxtv)
      deallocate(lab,ig,g)

      deallocate(idetb,nactb,inactb,ioccb,vecsb,civb)
      deallocate(ioccm,vecsm,civm)
      deallocate(idetm,inactm,nactm,nbasm,ncombv)
      deallocate(map2)

      deallocate(hbase,sbase,nsing)

      call timer_stop(4)
      call timer_stop(1)

       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  End of Hamiltonian calculation'
       flush(lfnday)
       call timer_start(99)
       
      call gronor_timings(lfnout)

       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Timings reported'
       flush(lfnday)
       call timer_start(99)
       
      if(me.eq.master) deallocate(numrecs)

      close(unit=lfndbg,status='keep')
      if(me.eq.master) then
       close(unit=lfnout,status='keep')
       if(ipro.ge.3) then
        close(unit=lfnpro,status='keep')
       else
        close(unit=lfnpro,status='delete')
       endif
       close(unit=lfnday,status='keep')
      else
!       if(ipr.lt.5) then
!        close(unit=lfnout,status='delete')
!       else
!        close(unit=lfnout,status='keep')
!       endif
!       close(unit=lfnpro,status='delete')
      endif

      return
 994  write(lfnout,984) filsym(1:inp_strlen(fildbg))
      call errquit()
 995  write(lfnout,985) filsym(1:inp_strlen(filsym))
      call errquit()
 996  write(lfnout,986) filout(1:inp_strlen(filout))
      call errquit()
 997  write(lfnout,987) filvec(1:inp_strlen(filvec))
      call errquit()
 998  write(lfnout,988) filciv(1:inp_strlen(filciv))
      call errquit()
 999  write(lfnout,989) filinp(1:inp_strlen(filinp))
      call errquit()
 984  format('Unable to open debug file ',a)
 985  format('Unable to open symmetry file ',a)
 986  format('Unable to open output file ',a)
 987  format('Unable to open vects file ',a)
 988  format('Unable to open civec file ',a)
 989  format('Unable to open input file ',a)
      end
      
