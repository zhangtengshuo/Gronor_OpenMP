      subroutine gronor_main()

!     initialization of the calculation

!     reading a root name from the command line
!     the root name will be used to generate all other
!     filenames associated with the calculation

!     $(root).inp is the input file
!     $(root).out is the output file
!     $(root).sym contains the symmetry of MOs for different sets,
!                 coordinates, basis set. This is the old fort.7 file
!     $(root)_nnn.civ contain the CI vectors, one for every nnn=1,mstates
!                 These files are generated by GAMES-UK (I7,F25.14,6x,10(I2,X))
!                 where the first line contains #det #nact #inact
!     $(root)_nnn.vec contain the vectors, one for every nnn=1,mstates
!                 These files are generated by GAMESS-UK and then modified
!                 using gam2sym2.x to get the same format as GNOME (4F18.14)

!     Need to specify the format and content of these files,
!     as well as the third party codes that generate them

      use mpi
      use inp
      use cidef
      use cidist
      use gnome_parameters
      use gnome_data
      use gnome_integrals

#ifdef CUSOLVER
      use cusolverDn
      use cuda_cusolver
#endif
#ifdef _OPENACC
      use openacc
      use cuda_functions
#endif
      
      implicit none

      integer (kind=4) :: ierror,ierr,istat
      integer :: iarg,i,j,idum(51),k,l,len,nn,ifac
      integer,allocatable :: iocc_tmp(:)
      integer :: maxci, maxvec, maxnact
      integer :: mactb, maxcib, mdum, node
      real (kind=8) :: sdum,ctime,wtime,rmat(2),rmatt(2),rdum(3)
      character (len=255) :: string, filnam, card, item

      real(kind=8), external :: timer_wall_total
      
      integer :: l1
      logical :: osame

      integer :: getcpucount
      external :: getcpucount

      integer :: im,is,ie,km,ks,ke,lm,ls,le,nm,ns,ne,n,kl,ll,nl
      integer :: nmax,kbloc

      integer :: igr, numone, numtwo
      integer (kind=4) :: new,newme,newgrp,newrnk
      integer :: maxcib1
      character (len=255) :: opt_inp
      real (kind=8), allocatable :: tc(:,:), hbt(:)

      character (len=4) :: token

      integer :: maxgrp
      integer :: nk,ii,il,ik

      integer :: ibase, jbase, ib, jb, l2, numdet, lnxt, lcur
      
#ifdef USE_POSIXF
      integer*4 len4,ierr4
#endif

#ifdef _OPENACC
      type(c_ptr) :: cpfre, cptot
#endif
      
      call timer_init()

      call timer_start(99)
      call timer_start(1)
      call timer_start(2)

      bias=0.0d0
      deta=0.0d0

      if(me.eq.master) then

       user='                  '
       host='                  '
       date='                  '
       time='                  '
       cwd='                   '

#ifdef USE_POSIXF
       call pxfgetlogin(user,len4,ierr4)
#else
       call getlog(user)
       call hostnm(host)
       call swatch(date,time)
       call getcwd(cwd)
#endif

!     Read a single string argument 'root' from the command line, that
!     will be used to generate all other files used to read and write
!     data associated with this calculation

!     input file: filinp with logical file number lfninp
!     output file: filout with logical file number lfnout
!     symmetry file: filsym with logical file number lfnsym
!     what is on?: filciv with logical file number lfnciv
!     what is on?: filvec with logical file number lfnvec

       iarg=0
       call getarg(iarg,command)
       iarg=1
       call getarg(iarg,string)

       root=string(1:inp_strlen(string))
       if(index(string,'_').gt.0) root=string(1:index(string,'_')-1)
       filinp=string(1:inp_strlen(string))//'.inp'
       lfninp=5
       filout=string(1:inp_strlen(string))//'.out'
       lfnout=16
       filsym=root(1:inp_strlen(root))//'.sym'
       lfnsym=7
       lfnciv=9
       lfnvec=10
       filint=root(1:inp_strlen(root))//'.int'
       filone=root(1:inp_strlen(root))//'.one'
       lfnint=11
       lfnone=11
       lfntwo=12
       lfndbg=13
       filpro=string(1:inp_strlen(string))//'.pro'
       lfnpro=14
       fildat=string(1:inp_strlen(string))//'.dat'
       lfndat=15
       filday=string(1:inp_strlen(string))//'.day'
       lfnday=18
       filtst=string(1:inp_strlen(string))//'.tst'
       lfntst=19
       lfnf74=74
       filf74=string(1:inp_strlen(string))//'.f74'
       lfnf75=75
       filf75=string(1:inp_strlen(string))//'.f75'

       open(unit=lfnout,file=filout(1:inp_strlen(filout)),
     &  form='formatted',status='unknown',err=996)

       open(unit=lfnpro,file=filpro(1:inp_strlen(filpro)),
     &  form='formatted',status='unknown',err=996)

       open(unit=lfnday,file=filday(1:inp_strlen(filday)),
     &      form='formatted',status='unknown',err=996)
       
       open(unit=lfntst,file=filtst(1:inp_strlen(filtst)),
     &  form='formatted',status='unknown',err=996)

       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Start of job'
  702  format(a8,2x,a8,f12.3,a)
       flush(lfnday)
       call timer_start(99)
           
       write(lfnout,600)
  600  format(/,
     &  ' GronOR: Non-Orthogonal Configuration Interaction program',//,
     &      4x,'T. P. Straatsma',t55,
     &      'C. de Graaf',t85,
     &      'R. W. A. Havenith and R. K. Kathir',/,
     &      4x,'National Center for Computational Sciences',t55,
     &      'Quantum Chemistry Group',t85,
     &      'Department of Theoretical Chemistry',/,
     &      4x,'Oak Ridge National Laboratory',t55,
     &      'University Rovira i Virgili',t85,
     &      'University of Groningen',/,
     &      4x,'Oak Ridge, Tennessee, USA',t55,
     &      'Tarragona, Spain',t85,
     &      'Groningen, the Netherlands',//,
     &      4x,'Based on GNOME written by R. Broer-Braam, ',
     &      'J. Th. van Montfort, and B. Vunderink',//,
     &      4x,'Please cite the following reference when publishing ',
     &      'results obtained using GronOR:',//,
     &      4x,'T. P. Straatsma, R. Broer, S. Faraji,',
     &      'R. W. A. Havenith, L. E. Aguilar Suarez, R. K. Kathir, ',
     &      'M. Wibowo, and C.de Graaf',/,
     &      4x,'"GronOR: Massively parallel and GPU-accelerated ',
     &      'non-orthogonal configuration interaction for large ',
     &      'molecular systems"',/,
     &      4x,'Journal of Chemical Physics, 152 (2020), ',
     &      'https://doi.org/10.1063/1.5141358',/)

       write(lfnout,601) trim(user),getcpucount(),
     &      trim(host),nnodes,
     &      date(1:8),nrsets,
     &      time(1:8),nrnsets,numdev,
     &      np,np/nnodes,np/nrsets,
     &      ncycls,num_threads,trim(command),trim(cwd),
     &      filinp(1:inp_strlen(filinp)),filsym(1:inp_strlen(filsym)),
     &      filout(1:inp_strlen(filout)),filone(1:inp_strlen(filone)),
     &      root(1:inp_strlen(root)),memfre,
     &      root(1:inp_strlen(root)),memtot

 601   format(//,
     &      ' User',t30,a,t60,'CPU count',t100,i10,/,/,
     &      ' Host',t30,a,t60,'Number of nodes',t100,i10,/,
     &      ' Date',t30,a,t60,
     &      'Number of resource sets',t100,i10,/,
     &      ' Time',t30,a,t60,
     &      'Number of resource sets per node',t100,i10,/,
     &      t60,'Number of NVIDIA devices per resource set',t100,i10,/,
     &      t60,'Number of MPI ranks',t100,i10,/,
     &      t60,'Number of MPI ranks per node',t100,i10,/,
     &      t60,'Number of MPI ranks per resource set',t100,i10,/,
     &      t60,'Number of rank assignment cycles',t100,i10,/,
     &      t60,'Number of OPENMP threads (OMP_NUM_THREADS)',t100,i10,//,
     &      ' Command argument',t30,a,/,
     &      ' Current working directory',t30,a,//,
     &      ' Input file is',t25,a,t60,
     &      'Symmetry file is',t92,a,/,
     &      ' Output file is',t25,a,t60,
     &      'One electron integral file is',t92,a,//,
     &      ' CI vector file(s) are',t25,a,'_nnn.civ',t60,
     &      'Available memory on device',t90,i20,/,
     &      ' MO vector file(s) are',t25,a,'_nnn.vec',t60,
     &      'Total memory on device',t90,i20,//)

!     Read from the input file

!     npg:     number of processes per group (default is 1)
!     nmol:    number of molecules
!     mstates: number of molecular states
!     nbase:   number of many-electron base (?)

!     and use these to allocate

!     ncombv(nmol,nbase): the combination
!     nbasm(mstates):    number of one-electron basis functions per monomer/state
!     inactm(mstates):   number of inactive orbitals per monomer/state
!     idetm(mstates):    number of determinants per monomer/state

!     Set defaults

       npg=0
       mgr=0
       nmol=0
       mstates=0
       iload=1
       ibatch=1
       itest=0
       idevel=0
       ifault=1
       isolver=1
       intadd=0
       naccel=-1
       ncols=7
       nummps=1
       numomp=1
       ixpert=0
#ifdef _OPENACC
       naccel=0
#endif
       nqcp=1
       ipr=-1
       itim=-1
       ipro=-1
       iday=10
       idbg=0
       nspin=0
       mpibuf=168435456
       thresh=1.0d-10
       thresh_CI=1.0d-10
       thresh_SIN=1.0d-12

       open(unit=lfninp,file=filinp,form='formatted',status='old',
     &  err=999)

 1     continue

       if(inp_read()) then

 2     continue

       if(.not.inp_a(item)) goto 1

 3     continue

       if(inp_compare(.false.,'Groups',item)) then
         if(.not.inp_i(npg)) call errquit()
         goto 2
       endif

       if(inp_compare(.false.,'Size',item)) then
         if(.not.inp_i(mgr)) call errquit()
         if(npg.eq.0) npg=(np-1)/mgr
         if(np.lt.mgr+1) then
           write(*,'(a,i5,a,i5,a)') 'Error: Size specified (',mgr,
     &          ') cannot be supported by available ranks (',np,')'
           call errquit()
         endif
         goto 2
       endif
       
       if(inp_compare(.false.,'Molecules',item)) then
         if(.not.inp_i(nmol)) call errquit()
         if(.not.inp_i(nbase)) call errquit()
         allocate(ncombv(nmol,nbase))
         do i=1,nmol
           if(.not.inp_read()) call errquit()
           do j=1,nbase
             if(.not.inp_i(ncombv(i,j))) call errquit()
             if(ncombv(i,j).eq.0) ncombv(i,j)=9
           enddo
         enddo
         goto 2
       endif
       
       if(inp_compare(.false.,'States',item)) then
         if(.not.inp_i(mstates)) mstates=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Spin',item)) then
         if(.not.inp_i(nspin)) call errquit()
         goto 2
       endif

       if(inp_compare(.false.,'Threshold',item)) then
         if(.not.inp_f(thresh)) call errquit()
         thresh_CI=thresh
         goto 2
       endif
       
       if(inp_compare(.false.,'Expert',item)) then
         if(.not.inp_i(ixpert)) ixpert=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Thresh_CI',item)) then
         if(.not.inp_f(thresh_CI)) thresh_CI=1.0d-10
         goto 2
       endif
       
       if(inp_compare(.false.,'Thresh_SIN',item)) then
         if(.not.inp_f(thresh_SIN)) thresh_SIN=1.0d-12
         goto 2
       endif
       
       if(inp_compare(.false.,'Load',item)) then
         if(.not.inp_i(iload)) iload=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Range',item)) then
         if(.not.inp_i(ibatch)) ibatch=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Batch',item)) then
         if(.not.inp_i(ibatch)) ibatch=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Print',item)) then
         if(.not.inp_i(ipr)) ipr=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Timings',item)) then
         if(.not.inp_i(itim)) itim=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Fault',item)) then
         if(.not.inp_i(ifault)) ifault=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Solver',item)) then
         if(.not.inp_i(isolver)) isolver=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Debug',item)) then
         if(.not.inp_i(idbg)) idbg=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Dayfile',item)) then
         if(.not.inp_i(iday)) iday=10
         goto 2
       endif
       
       if(inp_compare(.false.,'Progress',item)) then
         if(.not.inp_i(ipro)) ipro=1
         goto 2
       endif
       
       if(inp_compare(.false.,'Test',item)) then
         if(.not.inp_i(itest)) itest=0
         goto 2
       endif
       
       if(inp_compare(.false.,'Development',item)) then
         if(.not.inp_i(idevel)) idevel=0
         goto 2
       endif
       
       if(inp_compare(.false.,'IntAdd',item)) then
         if(.not.inp_i(intadd)) intadd=0
         goto 2
       endif
       
       if(inp_compare(.false.,'Maxcib',item)) then
         if(.not.inp_i(inpcib)) inpcib=0
         goto 2
       endif
       
       if(inp_compare(.false.,'Columns',item)) then
         if(.not.inp_i(ncols)) ncols=7
         goto 2
       endif
       
       if(inp_compare(.false.,'MPIbuffer',item)) then
         if(.not.inp_i(mpibuf)) call errquit()
         goto 2
       endif
       
       if(inp_compare(.false.,'Accelerate',item)) then
         if(.not.inp_i(naccel)) naccel=0
         goto 2
       endif
       
       if(inp_compare(.false.,'MPS',item)) then
         if(.not.inp_i(nummps)) nummps=1
         goto 2
       endif
       
       if(inp_compare(.false.,'OMP',item)) then
         if(.not.inp_i(numomp)) numomp=1
         goto 2
       endif
       
       if(inp_compare(.false.,'QCprogram',item)) then
         if(.not.inp_a(opt_inp)) opt_inp='symol'
         if(inp_compare(.false.,'symol',opt_inp)) then
           nqcp=1
         else if(inp_compare(.false.,'gamess',opt_inp)) then
           nqcp=2
         else if(inp_compare(.false.,'molcas',opt_inp)) then
           nqcp=3
         end if
         goto 2
       endif
       
       goto 1
      endif
      
      
      if(mgr.eq.0) then
        if(npg.eq.0) call errquit()
        mgr=(np-1)/npg
      endif
      
!     Unless the user is an expert let's check thresholds
      
      if(ixpert.eq.0) then
        thresh=min(thresh,1.0d-05)
        thresh_CI=min(thresh_CI,1.0d-05)
      endif
      
      call gronor_number_integrals(numone,numtwo)
      
!     Coen: Warning, numone and numtwo are read from a dummy entry. The real
!           number of two electron integrals is on the next record of the 1-el
!           integral file. Now, they always take the values 8421 and -1. 
!           When npg = 0, something very strange will come out (I guess).
       
      if(npg.eq.0) then
        npg=numtwo/intsrnk
        if(mod(numtwo,intsrnk).gt.0) npg=npg+1
      endif
      
      if(mgr.eq.0) then
        if(iload.eq.0) mgr=np/npg
        if(iload.eq.1) mgr=(np-1)/npg
      else
        if(npg*mgr+1.gt.np) then
          write(lfnout,983)
 983      format(' Requested number of ranks exceeds available')
          call errquit()
        endif
      endif
      
      allocate(nbasm(mstates))
      allocate(nactm(mstates))
      allocate(inactm(mstates))
      allocate(idetm(mstates))
      
      iocc(1)=1
      iocc(2)=2
      iord(1)=0
      iord(2)=0
      indx(1)=0
      indx(2)=0
      icalc=0
      ins2=0
      ipvec=0
      idipole=0
      itp4=0
      ione=0
      bias=0.0d0
      corres=.false.
      
      close(unit=lfninp)
      
      write(lfnout,622) isolver,numomp
 622  format(' Solver option',t40,i10,t60,
     &     'Number of OpenMP threads per MPI (OMP)',t100,i10)
      if(ifault.eq.0) then
        write(lfnout,627),nummps
 627    format(' No fault tolerance',t60,'
     &       Over-subscription of accelerators (MPS)',t100,i10)
      else
        write(lfnout,625) ifault,nummps
 625    format(' Fault tolerance wait time',t40,i10,' sec',t60,
     &       'Over-subscription of accelerators (MPS)',t100,i10)
      endif
      write(lfnout,626) itest,mgr,idevel,nmol,ibatch,mstates,
     &     nbase
 626  format(' Test option',t40,i10,t60,
     &     'Integrals divided over tasks number of ranks',t100,i10,/,
     &     ' Development option',t40,i10,t60,
     &     'Number of molecules (nmol)',t100,i10,/,
     &     ' Batch size',t40,i10,t60,
     &     'Number of molecular states (mstates)',t100,i10,/,t60,
     &     'Number of many-electron states (nbase)',t100,i10,/)

      write(lfnout,623) thresh_CI, thresh_SIN
 623  format(' Threshold for CI coefficients',t40,1pe12.3,/,
     &     ' Threshold for ISING',t40,1pe12.3,/)
      
      maxci=0
      maxvec=0
      maxnact=0
      
      if(ipr.ge.1) write(lfnout,604)
 604  format(/,' Dimensions',//,
     &     '  istate   ndetm   nactm  ninatm   nbasm   files',/)
      
      do i=1,mstates
        write(filciv,200) root(1:inp_strlen(root)),i
 200    format(a,'_',i3.3,'.civ')
        len=inp_strlen(filciv)
        open(unit=lfnciv,file=filciv(1:len),form='formatted',
     &       status='old',err=998)
        read(lfnciv,*) idetm(i),nactm(i),inactm(i)
        close(unit=lfnciv)
        write(filvec,201) root(1:inp_strlen(root)),i
 201    format(a,'_',i3.3,'.vec')
        len=inp_strlen(filvec)
        open(unit=lfnvec,file=filvec(1:len),form='formatted',
     &       status='old',err=998)
        read(lfnvec,*) nbasm(i)
        close(unit=lfnvec)
        maxci=max(maxci,idetm(i))
        maxvec=max(maxvec,nbasm(i))
        maxnact=max(maxnact,nactm(i))
        if(ipr.ge.1)
     &       write(lfnout,605) i,idetm(i),nactm(i),inactm(i),nbasm(i),
     &       filciv(1:inp_strlen(filciv)),filvec(1:inp_strlen(filvec))
 605    format(5i8,3x,a,', ',a)
      enddo
      
       if(ipr.ge.1) write(lfnout,606) maxci,maxnact,maxvec
 606   format(8x,'  ------  ------',8x,'  ------',/,
     &  '    max:',i8,i8,8x,i8)

       allocate(civm(maxci,mstates))
       allocate(vecsm(maxvec,maxvec,mstates))
       allocate(ioccm(maxnact,maxci,mstates))
       
       write(lfnout,613) (i,i=1,nbase)
 613   format(/,' Molecular states included in this calculation',//,
     &      ' State        : ',20i4)
       write(lfnout,624)
 624   format(/)
       do i=1,nmol
         write(lfnout,617) i,(ncombv(i,j),j=1,nbase)
 617     format(' Molecule',i4,' : ',20i4)
       enddo
       
       if(ipr.ge.3) write(lfnout,607)
 607   format(//,'  istate   idetm           ci coefficient')
       
!     Coen Oct17_19: changed idum for iocc_tmp, idum is used later for
!     something completely different.
       
       allocate( iocc_tmp(maxnact) )
       do i=1,mstates
         iocc_tmp = 0
         write(filciv,200) root(1:inp_strlen(root)),i
         len=inp_strlen(filciv)
         open(unit=lfnciv,file=filciv(1:len),form='formatted',
     &        status='old',err=998)
         read(lfnciv,*)
         do j=1,idetm(i)
           read(lfnciv,1002) nn,civm(j,i),(iocc_tmp(k),k=1,nactm(i))
 1002      format(i7,f25.14,6x,20(i2,x))
           if(j.eq.1) then
             write(lfnout,608) i,nn,civm(j,i),(iocc_tmp(k),k=1,nactm(i))
 608         format(/,2i8,f25.14,6x,20(i2.2,1x))
           else
             write(lfnout,609) nn,civm(j,i),(iocc_tmp(k),k=1,nactm(i))
 609         format(8x,i8,f25.14,6x,20(i2.2,1x))
           endif
           do k=1,nactm(i)
             if(iocc_tmp(k).eq.11) then
               ioccm(k,j,i)=2
             elseif(iocc_tmp(k).eq.1) then
               ioccm(k,j,i)=-1
             elseif(iocc_tmp(k).eq.10) then
               ioccm(k,j,i)=1
             elseif(iocc_tmp(k).eq.0) then
               ioccm(k,j,i)=0
             else
               print *,(iocc_tmp(l),l=1,nactm(i))
               stop 'weird occupation'
             endif
           enddo
         enddo
         close(unit=lfnciv)
         
         write(filvec,201) root(1:inp_strlen(root)),i
         len=inp_strlen(filvec)
         open(unit=lfnvec,file=filvec(1:len),form='formatted',
     &        status='old',err=998)
         read(lfnvec,*)
         if(ipr.ge.4) then
           write(lfnout,2002) filvec(1:len),nbasm(i)
 2002      format(/,' Vector File ',a,//,
     &          ' Number of basis functions ',i8,/)
         endif
         do j=1,nbasm(i)
           read(lfnvec,1003) (vecsm(k,j,i),k=1,nbasm(i))
 1003      format(4F18.14)
           if(ipr.ge.4) then
             write(lfnout,2003) j,(vecsm(k,j,i),k=1,nbasm(i))
 2003        format(i5,5f25.14,/,(5x,5f25.14))
           endif
         enddo
         close(unit=lfnvec)
         flush(lfnout)
       enddo
       deallocate (iocc_tmp)
       write(filsym,202) root(1:inp_strlen(root))
 202   format(a,'.sym')
       len=inp_strlen(filsym)
       open(unit=lfnsym,file=filsym(1:len),form='formatted',
     &      status='old',err=995)
       
       if(ipr.ge.3) write(lfnout,610) filsym(1:inp_strlen(filsym))
 610   format(/,' System information read from ',a,/)
       
!     Coen: remove SYMOL from the list of QC programs
!     if (nqcp.eq.1) then
!     call gronor_gnome_symmetry_input(lfnsym,lfnout,ipr)
!     elseif (nqcp.eq.2) then
       
       if ( nqcp .eq. 2 ) then
         call gronor_gnome_symmetry_input_gamess(lfnsym,lfnout,ipr)
       elseif (nqcp.eq.3) then
         call gronor_gnome_molcas_input(lfnsym,lfnout,ipr) ! OpenMolcas
       endif
       close(unit=lfnsym)
       
      else                      ! belonging to "if(inp_read()) then" (I guess)
        lfnout=6
        write(filout,650) me
 650    format('gronor_',i5.5,'.dbg')
        if(ipr.ge.10) then
          open(unit=lfnout,file=filout(1:inp_strlen(filout)),
     &         form='formatted',status='unknown',err=996)
        endif
      endif

!     Distribute input data to all processes

      if(np.gt.1) then
        
        if(me.eq.master) then
          idum(1)=nmol
          idum(2)=mstates
          idum(3)=nbase
          idum(4)=maxci
          idum(5)=maxvec
          idum(6)=maxnact
          idum(7)=iocc(1)
          idum(8)=iocc(2)
          idum(9)=iord(1)
          idum(10)=iord(2)
          idum(11)=indx(1)
          idum(12)=indx(2)
          idum(13)=icalc
          idum(14)=ipr
          idum(15)=ins2
          idum(16)=ipvec
          idum(17)=itp4
          idum(18)=ione
          idum(19)=0
          if(corres) idum(19)=1
          idum(20)=npg
          idum(21)=nnucl
          idum(22)=nbas
          idum(23)=iload
          idum(24)=ibatch
          idum(25)=mgr
          idum(26)=itest
          idum(27)=naccel
          idum(28)=inpcib
          idum(29)=ipro
          idum(30)=intadd
          idum(31)=mpibuf
          idum(32)=idbg
          idum(33)=nummps
          idum(34)=numomp
          idum(35)=itim
          idum(36)=isolver
          idum(37)=ifault
          idum(38)=idevel
          
          rdum(1)=thresh
          rdum(2)=thresh_CI
          rdum(3)=thresh_SIN
        endif
        
        call MPI_Bcast(idum,38,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
        call MPI_Bcast(rdum,3,MPI_REAL8,master,MPI_COMM_WORLD,ierr)
        
        nmol   =idum(1)
        mstates=idum(2)
        nbase  =idum(3)
        maxci  =idum(4)
        maxvec =idum(5)
        maxnact=idum(6)
        iocc(1)=idum(7)
        iocc(2)=idum(8)
        iord(1)=idum(9)
        iord(2)=idum(10)
        indx(1)=idum(11)
        indx(2)=idum(12)
        icalc  =idum(13)
        ipr    =idum(14)
        ins2   =idum(15)
        ipvec  =idum(16)
        itp4   =idum(17)
        ione   =idum(18)
        corres =idum(19).eq.1
        npg    =idum(20)
        nnucl  =idum(21)
        nbas   =idum(22)
        iload  =idum(23)
        ibatch =idum(24)
        mgr    =idum(25)
        itest  =idum(26)
        naccel =idum(27)
        inpcib =idum(28)
        ipro   =idum(29)
        intadd =idum(30)
        mpibuf =idum(31)
        idbg   =idum(32)
        nummps =idum(33)
        numomp =idum(34)
        itim   =idum(35)
        isolver=idum(36)
        ifault =idum(37)
        idevel =idum(38)
        
        thresh=rdum(1)
        thresh_CI=rdum(2)
        thresh_SIN=rdum(3)
        
      endif
      
#ifdef _OPENMP
      if(numomp.gt.0) num_threads=numomp
      if(num_threads.gt.0) call omp_set_num_threads(num_threads)
#endif

      lfnone=11
      lfntwo=12
      lfndbg=13
      if(idbg.gt.0) then
        write(fildbg,1300) me
 1300   format('GronOR_',i5.5,'.dbg ')
        open(unit=lfndbg,file=fildbg(1:inp_strlen(fildbg)),
     &       form='formatted',status='unknown',err=996)
      endif
      
      nacc0=naccel
      nacc1=naccel
      
      if(me.ne.master) then
        nmol   =idum(1)
        mstates=idum(2)
        nbase  =idum(3)
        maxci  =idum(4)
        maxvec =idum(5)
        maxnact=idum(6)
        
        allocate(ncombv(nmol,nbase))
        allocate(nbasm(mstates))
        allocate(nactm(mstates))
        allocate(inactm(mstates))
        allocate(idetm(mstates))
        allocate(civm(maxci,mstates))
        allocate(vecsm(maxvec,maxvec,mstates))
        allocate(ioccm(maxnact,maxci,mstates))
  
        iocc(1)=idum(7)
        iocc(2)=idum(8)
        iord(1)=idum(9)
        iord(2)=idum(10)
        indx(1)=idum(11)
        indx(2)=idum(12)
        icalc  =idum(13)
        ipr    =idum(14)
        ins2   =idum(15)
        ipvec  =idum(16)
        itp4   =idum(17)
        ione   =idum(18)
        corres =idum(19).eq.1
      endif
      if(np.gt.0) then
        call MPI_Bcast(nqcp,1,MPI_INTEGER8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(civm,maxci*mstates,MPI_REAL8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(vecsm,maxvec*maxvec*mstates,MPI_REAL8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(ioccm,maxnact*maxci*mstates,MPI_INTEGER8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(ncombv,nmol*nbase,MPI_INTEGER8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(nbasm,mstates,MPI_INTEGER8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(nactm,mstates,MPI_INTEGER8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(inactm,mstates,MPI_INTEGER8,master,
     &       MPI_COMM_WORLD,ierr)
        call MPI_Bcast(idetm,mstates,MPI_INTEGER8,master,
     &       MPI_COMM_WORLD,ierr)
      endif
      
      nbasis=0
      mactb=0
      do i=1,nmol
        nbasis=nbasis+nbasm(ncombv(i,1))
        mactb=mactb+nactm(ncombv(i,1))
      enddo
      
      maxcib=0
      do i=1,nbase
        maxcib1=1
        do j=1,nmol
          maxcib1=maxcib1*idetm(ncombv(j,i))
        enddo
        maxcib=max(maxcib,maxcib1)
      enddo
      maxcib=6*maxcib
      if (me.eq.master) then
        write(lfnout,629) maxcib
 629    format(/,' Recommended value of maxcib is ',i10)
      endif
      if(inpcib.ne.0) maxcib=inpcib
      
      allocate(civb(maxcib,nbase))
      allocate(vecsb(nbasis,nbasis,nbase))
      allocate(ioccb(maxcib,nbase))
      allocate(inactb(nbase))
      allocate(nactb(nbase))
      allocate(idetb(nbase))
      
      ngr=(np-1)/mgr

      allocate(ranks_heads(ngr+1))

      master=np-1

      if(ncycls.gt.1) then
       j=0
       do i=1,np
        if(map2(i,5).gt.0) j=j+1
       enddo
       do i=1,min(np,nummps*j)
        map2(i,5)=map2(i,1)
       enddo
      else
      node=map2(1,4)
      j=nummps*map2(1,1)
      do i=1,np
        map2(i,2)=numomp
        if(map2(i,4).eq.node) then
          if(j.gt.0) then
            map2(i,5)=map2(i,1)
            if(naccel.lt.0) map2(i,5)=-map2(i,2)
            j=j-1
          else
            map2(i,5)=-map2(i,2)
          endif
        else
          node=map2(i,4)
          j=nummps*map2(i,1)
          if(j.gt.0) then
            map2(i,5)=map2(i,1)
            if(naccel.lt.0) map2(i,5)=-map2(i,2)
            j=j-1
          else
            map2(i,5)=-map2(i,2)
          endif
        endif
        if(i-1.eq.master) map2(i,5)=0
      enddo
      endif
      
      if(me.eq.master) then
        numacc=0
        numnon=0
        do i=1,np
          if(map2(i,5).gt.0) numacc=numacc+1
          if(map2(i,5).lt.0) numnon=numnon+1
        enddo
        numacc=numacc/mgr
        numnon=numnon/mgr
        maxgrp=numacc+numnon
      endif
      call MPI_Bcast(maxgrp,1,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      allocate(thisgroup(mgr+1))
      allocate(allgroups(maxgrp+1,mgr+1))
      allocate(allheads(maxgrp+1))
      if(me.eq.master) then
        numgrp=0
        igr=0
        do i=1,np
          if(map2(i,5).gt.0) then
            if(igr.eq.0) numgrp=numgrp+1
            igr=igr+1
            allgroups(numgrp,1)=map2(i,5)
            allgroups(numgrp,igr+1)=i-1
            if(igr.eq.mgr) igr=0
          endif
        enddo

        if(igr.ne.0.and.numgrp.gt.0) numgrp=numgrp-1
        igr=0
        do i=1,np
          if(map2(i,5).lt.0) then
            if(igr.eq.0) numgrp=numgrp+1
            igr=igr+1
            allgroups(numgrp,1)=map2(i,5)
            allgroups(numgrp,igr+1)=i-1
            if(igr.eq.mgr) igr=0
          endif
        enddo

        if(igr.ne.0.and.numgrp.gt.0) numgrp=numgrp-1
        do i=1,numgrp
          allheads(i)=allgroups(i,2)
          do j=1,mgr
            map2(allgroups(i,j+1)+1,3)=i
          enddo
        enddo
        allheads(numgrp+1)=master
      endif
      call MPI_Bcast(numgrp,1,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(map2,5*np,MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(allgroups,int((maxgrp+1)*(mgr+1),kind=4),
     &     MPI_INTEGER8,master,MPI_COMM_WORLD,ierr)
      call MPI_Bcast(allheads,int(maxgrp,kind=4),MPI_INTEGER8,master,
     &     MPI_COMM_WORLD,ierr)
      if(numgrp.eq.0) then
        write(*,'(a)') 'Number of groups is zero'
        call errquit()
      endif
      do i=1,numgrp
        do j=1,mgr
          if(me.eq.allgroups(i,j+1)) then
            do k=1,mgr+1
              thisgroup(k)=allgroups(i,k)
            enddo
          endif
        enddo
      enddo
      
      if(me.ne.master) then
        iamhead=0
        if(me.eq.thisgroup(2)) iamhead=1
        myhead=thisgroup(2)
        numdev=thisgroup(1)
        if(numdev.lt.0) numdev=0
      else
        myhead=master
        numdev=0
      endif
      
      mygroup=0
      do i=1,numgrp
        ranks_heads(i)=allgroups(i,2)
        do j=1,mgr
          if(me.eq.allgroups(i,j+1)) mygroup=i
        enddo
      enddo
      ranks_heads(numgrp+1)=master
      
      new=-1
      
      call MPI_Comm_Group(MPI_COMM_WORLD,group_world,ierr)
      
      call MPI_Group_incl(group_world,int(numgrp+1,kind=4),ranks_heads,
     &     group_heads,ierr)
      if(iamhead.eq.1) then
        call MPI_Group_Rank(group_heads,new,ierr)
      endif
      
      if(me.eq.master) then
        write(lfnout,630)
 630    format(//,' MPI Rank Assignments')
 635    format(/,' Accelerated Groups')
        if(ipr.lt.2) then
        k=1
        l=min(k+14,numacc)
        if(numacc.gt.0) then
          write(lfnout,635)
          do while (k.le.l)
            write(lfnout,634)
 634        format(/)
            write(lfnout,631) (j,j=k,l)
 631        format(10x,15i8)
            write(lfnout,632) (' ----',j=k,l)
 632        format(10x,15a8)
            do i=2,mgr+1
              write(lfnout,631) (allgroups(j,i),j=k,l)
            enddo
            k=l+1
            l=min(k+14,numacc)
          enddo
          write(lfnout,634)
        endif
        if(numnon.gt.0) then
          write(lfnout,633)
 633      format(/,' Non-Accelerated Groups')
          k=l+1
          l=min(k+14,numgrp)
          do while (k.le.l)
            write(lfnout,634)
            write(lfnout,631) (j,j=k,l)
            write(lfnout,632) (' ----',j=k,l)
            do i=2,mgr+1
              write(lfnout,631) (allgroups(j,i),j=k,l)
            enddo
            k=l+1
            l=min(k+14,numgrp)
          enddo
        endif
       else
        k=1
        l=min(k+7,numacc)
        if(numacc.gt.0) then
          write(lfnout,635)
          do while (k.le.l)
            write(lfnout,634)
            write(lfnout,1631) (j,j=k,l)
 1631        format(10x,8i16)
 1633        format(10x,8(i8,'/',i7))
            write(lfnout,1632) (' ------------',j=k,l)
 1632        format(10x,8a16)
            do i=2,mgr+1
              write(lfnout,1633) ((allgroups(j,i),
     & map2(allgroups(j,i)+1,4)),j=k,l)
            enddo
            k=l+1
            l=min(k+7,numacc)
          enddo
          write(lfnout,634)
        endif
        if(numnon.gt.0) then
          write(lfnout,633)
          k=l+1
          l=min(k+7,numgrp)
          do while (k.le.l)
            write(lfnout,634)
            write(lfnout,1631) (j,j=k,l)
            write(lfnout,1632) (' ------------',j=k,l)
            do i=2,mgr+1
              write(lfnout,1633) ((allgroups(j,i),
     & map2(allgroups(j,i)+1,4)),j=k,l)
            enddo
            k=l+1
            l=min(k+7,numgrp)
          enddo
        endif
       endif
      endif
      
      iamacc=0
      iamactive=0
      if(me.eq.master) iamactive=1
      if(me.ne.master.and.thisgroup(1).gt.0) then
        do i=1,mgr
          if(me.eq.thisgroup(i+1)) iamacc=1
        enddo
      endif
      if(thisgroup(1).ne.0) then
        do i=1,mgr
          if(me.eq.thisgroup(i+1)) iamactive=1
        enddo
      endif
      
      if(iamacc.eq.1) then

!     only accelerated ranks need to set device

#ifdef _OPENACC
      if(numdev.gt.1) then
       mydev=mod(me,numdev)
       call acc_set_device_num(mydev,ACC_DEVICE_NVIDIA)
       cpfre=c_loc(memfre)
       cptot=c_loc(memtot)
       istat=cudaMemGetInfo(cpfre,cptot)
       memavail=memfre
      endif
#endif
      
!     only accelerated ranks need to define cusolver handles
        
#ifdef CUSOLVER
      cusolver_status = cusolverDnCreate(cusolver_handle)
      if (cusolver_status /= CUSOLVER_STATUS_SUCCESS)
     &   print *, me,'cusolver_handle creation failed'

!      if(numdev.gt.1) then
!       cpfre=c_loc(memfre)
!       cptot=c_loc(memtot)
!       istat=cudaMemGetInfo(cpfre,cptot)
!      endif

#endif
      else
!     only non-accelerated ranks will use OpenMP threads

        
      endif
      
      if(me.eq.master) write(lfnout,611) nbase,nmol,nbasis
 611  format(//,' Dimensions',//,
     &     ' Number of states (nbase)',t40,i10,t60,
     &     'Number of molecules (nmol)', t100,i10,/,
     &     ' Number of basis functions (nbasis)',t40,i10)
      
      do i=1,nbase
        
        if(me.eq.master.and.ipr.ge.5) write(lfnout,612) i
 612    format(/,' Base state',i4)
        call gronor_makebasestate
     &       (lfnout,civm,vecsm,ioccm,nbasm,nactm,inactm,
     &       idetm,maxci,maxvec,maxnact,mstates,civb(1,i),vecsb(1,1,i),
     &       ioccb(1,i),inactb(i),nactb(i),idetb(i),maxcib,nbasis,mactb,
     &       nmol,ncombv(1,i),nspin,thresh_CI)
        
      enddo

      numdet=0
      do ibase=1,nbase
        do jbase=1,ibase
          ndeti=idetb(ibase)
          ndetj=idetb(jbase)
          osame=ibase.eq.jbase
          call iloop_init(ndeti,ndetj,osame)
          if(ibase.eq.jbase) then
            l2=ndeti*(ndeti+1)/2
            ijend=l2
          else
            l2=ndeti*ndetj
            ijend=l2
          endif
          l=0
          do k=1,l2
            i=iloop(k,1)
            j=iloop(k,2)
            l=l+1
          enddo
          numdet=numdet+l
        enddo
      enddo

      allocate(ndxdet(nbase,nbase))
      allocate(lstdet(numdet,2))

      l=0
      numdet=0
      do ibase=1,nbase
        do jbase=1,ibase
          ndeti=idetb(ibase)
          ndetj=idetb(jbase)
          osame=ibase.eq.jbase
          call iloop_init(ndeti,ndetj,osame)
          if(ibase.eq.jbase) then
            l2=ndeti*(ndeti+1)/2
            ijend=l2
          else
            l2=ndeti*ndetj
            ijend=l2
          endif
          l=0
          do k=1,l2
            i=iloop(k,1)
            j=iloop(k,2)
            if(dabs(civb(i,ibase)*civb(j,jbase)).ge.thresh_CI) then
              numdet=numdet+1
              l=l+1
              lstdet(numdet,1)=i
              lstdet(numdet,2)=j
            endif
          enddo
          ndxdet(jbase,ibase)=numdet
          ndxdet(ibase,jbase)=numdet
        enddo
      enddo

! Following Bcasts should not be necessary, but added for safety

!      call MPI_Bcast(ndxdet,nbase*nbase,MPI_INTEGER8,master,
!     &     MPI_COMM_WORLD,ierr)
!      call MPI_Bcast(lstdet,numdet*2,MPI_INTEGER8,master,
!     &     MPI_COMM_WORLD,ierr)

      if(me.ne.master) then
        lnxt=0
        lcur=0
        do ibase=1,nbase
          do jbase=1,ibase
            lcur=ndxdet(ibase,jbase)
            ndxdet(ibase,jbase)=lnxt
            lnxt=lcur
          enddo
        enddo
      endif
      
      if(me.eq.master) then
        call timer_stop(99)
        call swatch(date,time)
        write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Base states generated'
        flush(lfnday)
        call timer_start(99)
      endif
      
      allocate(hbase(nbase,nbase),sbase(nbase,nbase),tbase(nbase,nbase))
      allocate(nsing(nbase,nbase,5))
      
!     Define the process groups
      
      if(npg.le.0) npg=1
      if(npg.gt.np) npg=np
      ngr=np/npg
      
      if(me.eq.master.and.ipr.ge.0) then
        write(lfnout,618) np,numgrp,np-numgrp*mgr-1,mgr
 618    format(/,' Process Distribution',//,
     &       ' Number of processes',t40,i10,t60,
     &       'Number of process groups',t100,i10,/,
     &       ' Number of idle processes',t40,i10,t60,
     &       'Number of processes per group',t100,i10)
      endif
      
      call timer_stop(2)
      call timer_start(3)
      
!     Read the integrals from lfnint
      
      call gronor_read_integrals()
      
      if(me.eq.master) then
        call timer_stop(99)
        call swatch(date,time)
        write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Integrals read and distributed'
        flush(lfnday)
        call timer_start(99)
      endif
      
      if(me.eq.master.and.ipr.ge.0) then
        write(lfnout,614) nbas
        write(lfnout,615) int1
        write(lfnout,616) int2
 614    format(' Number of basisfunctions',t62,20i4)
 615    format(' Number of one-electron integrals',t50,i16)
 616    format(' Number of two-electron integrals',t50,i16)
      endif
      
      call timer_stop(3)
      call timer_start(4)
      
      if(me.eq.master.and.ipr.ge.5) then
        write(lfnout,628) nbase,nbase*(nbase+1)/2
 628    format(' Number of base states',t50,i16,/,                       &
     &       ' Number of base state elements',t50,i16)
      endif
      
      if(me.eq.master) flush(lfnout)
      
      if(me.eq.master) then
        allocate(numrecs(np))
        do i=1,np
          numrecs(i)=0
        enddo
      endif
      
      if(me.eq.master) then
        call timer_stop(99)
        call swatch(date,time)
        write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  Start Hamiltonian calculation'
        flush(lfnday)
        call timer_start(99)
      endif
      
        if(idbg.gt.0) then
          call swatch(date,time)
          write(lfndbg,'(a,1x,a,1x,a,10i5)') date(1:8),time(1:8),
     &         ' NVIDIA ',numdev,mydev,iamacc,nummps,
     &           (map2(me+1,i),i=1,5)
          flush(lfndbg)
        endif

      call timer_start(98)
      if(me.eq.master.and.iload.eq.1) then
        if(idbg.gt.0) then
          call swatch(date,time)
          write(lfndbg,'(a,1x,a,1x,a)') date(1:8),time(1:8),
     &         ' Calling GronOR_master'
          flush(lfndbg)
        endif
        call gronor_master()
      else
        if(idbg.gt.0) then
          call swatch(date,time)
          write(lfndbg,'(a,1x,a,1x,a,2i5)') date(1:8),time(1:8),
     &         ' iamactive, iamacc = ',iamactive,iamacc
          flush(lfndbg)
        endif
        if(iamactive.eq.1) then
          if(iamacc.eq.1) then
            if(idbg.gt.0) then
              call swatch(date,time)
              write(lfndbg,'(a,1x,a,1x,a,i12)') date(1:8),time(1:8),
     &             ' mint2= ',mint2
              flush(lfndbg)
            endif

!$acc data copyin(g,lab,t,v,ndxtv)
            if(idbg.gt.0) then
              call swatch(date,time)
              write(lfndbg,'(a,1x,a,1x,a)') date(1:8),time(1:8),
     &             ' Calling GronOR_worker'
              flush(lfndbg)
            endif
            call gronor_worker()
!$acc end data

       else
         lwork=10
         allocate(work(lwork))
         call gronor_worker()
       endif
      endif
      endif
      call timer_stop(98)
      
      if(idbg.gt.0) then
       call swatch(date,time)
       write(lfndbg,'(a,1x,a,a,a)') date(1:8),time(1:8),
     & ' Closing ',trim(fildbg)
       flush(lfndbg)
       close(unit=lfndbg,status='keep')
      endif

      if(me.eq.master) then
       write(lfnout,674)
 674   format(//,' Hamiltonian Matrix unnormalised',/)
       open(unit=lfnf74,file=filf74,form='unformatted',status='unknown')
       write(74)nbase
       write(74)((hbase(j,i),i=1,j),j=1,nbase)
       write(74)((sbase(j,i),i=1,j),j=1,nbase)
       close(unit=lfnf74,status='keep')

       nk=nbase/ncols
       if(mod(nbase,ncols).ne.0) nk=nk+1
       do k=1,nk
         ii=(k-1)*ncols+1
         il=min(nbase,k*ncols)
         write(lfnout,671) (i,i=ii,il)
         do j=1,nbase
           write(lfnout,672) j,(hbase(i,j),i=ii,il)
         enddo
         write(lfnout,*) ' '
       enddo

       nk=nbase/ncols
       if(mod(nbase,ncols).ne.0) nk=nk+1
       do k=1,nk
         ii=(k-1)*ncols+1
         il=min(nbase,k*ncols)
         write(lfnout,675)
 675     format(//,' Overlap Matrix unnormalised',/)
         write(lfnout,671) (i,i=ii,il)
         do j=1,nbase
           write(lfnout,672) j,(sbase(i,j),i=ii,il)
         enddo
         write(lfnout,*) ' '
       enddo
      endif

      if(me.eq.master) then
       do i=1,nbase
        do j=1,i-1
         hbase(i,j)=(1.0d0/(dsqrt(sbase(i,i))*
     &    dsqrt(sbase(j,j))))*hbase(i,j)
         sbase(i,j)=(1.0d0/(dsqrt(sbase(i,i))*
     &    dsqrt(sbase(j,j))))*sbase(i,j)
         hbase(j,i)=hbase(i,j)
         sbase(j,i)=sbase(i,j)
        enddo
       enddo
       do i=1,nbase
        hbase(i,i)=(1.0d0/sbase(i,i))*hbase(i,i)
        sbase(i,i)=(1.0d0/sbase(i,i))*sbase(i,i)
       enddo
      endif

      if(me.eq.master) then
        allocate(hbt(nbase))
        write(*,670)
        nk=nbase/ncols
        if(mod(nbase,ncols).ne.0) nk=nk+1
        do k=1,nk
          ii=(k-1)*ncols+1
          il=min(nbase,k*ncols)
          write(lfnout,670)
          write(lfntst,670)
 670      format(//,' Hamiltonian Matrix',/)
          write(*,671) (i,i=ii,il)
          write(lfnout,671) (i,i=ii,il)
          write(lfntst,671) (i,i=ii,il)
 671      format(6x,7(6x,i8,6x))
          do j=1,nbase
            write(*,672) j,(hbase(i,j),i=ii,il)
            write(lfnout,672) j,(hbase(i,j),i=ii,il)
 672        format(i5,1x,10f20.10)
            do i=ii,il
              hbt(i)=hbase(i,j)
              if(dabs(hbt(i)).lt.1.0d-08) hbt(i)=0.0d0
            enddo
            write(lfntst,1672) j,(hbt(i),i=ii,il)
 1672       format(i5,1x,10f20.8)
          enddo
          write(lfnout,*) ' '
          write(*,*) ' '
        enddo
        write(*,673)
        nk=nbase/ncols
        if(mod(nbase,ncols).ne.0) nk=nk+1
        do k=1,nk
          ii=(k-1)*ncols+1
          il=min(nbase,k*ncols)
          write(lfnout,673)
          write(lfntst,673)
 673      format(//,' Overlap Matrix',/)
          write(*,671) (i,i=ii,il)
          write(lfnout,671) (i,i=ii,il)
          write(lfntst,671) (i,i=ii,il)
          do j=1,nbase
            write(*,672) j,(sbase(i,j),i=ii,il)
            write(lfnout,672) j,(sbase(i,j),i=ii,il)
            do i=ii,il
              hbt(i)=sbase(i,j)
              if(dabs(hbt(i)).lt.1.0d-08) hbt(i)=0.0d0
            enddo
            write(lfntst,1672) j,(hbt(i),i=ii,il)
          enddo
          write(lfnout,*) ' '
          write(*,*) ' '
        enddo
        
        deallocate(hbt)
        
        open(unit=lfnf75,file=filf75,form='unformatted')
        write(75)nbase
        write(75)((hbase(j,i),i=1,j),j=1,nbase)
        write(75)((sbase(j,i),i=1,j),j=1,nbase)
        close(unit=lfnf75,status='keep')
        
        if(nbase.gt.1) then
          allocate(tc(nbase,nbase))
          do i=2,nbase
            do j=1,i-1
              tc(i,j)=hbase(i,j)
     &             -0.5d0*(hbase(i,i)+hbase(j,j))*sbase(i,j)/
     &             (1.0d0-sbase(i,j)*sbase(i,j))
            enddo
          enddo

          write(lfnout,676)
          write(*,676)
 676      format(//,' Electronic Couplings',/)
          nk=nbase/ncols
          if(mod(nbase,ncols).ne.0) nk=nk+1
          do k=1,nk
            ii=(k-1)*ncols+1
            il=min(nbase,k*ncols)
            write(lfnout,671) (i,i=ii,il)
            write(*,671) (i,i=ii,il)
            do j=1,nbase
              if(j.eq.1) then
                write(lfnout,672) 1
                write(*,672) 1
              else
                ik=min(j-1,il)
                write(lfnout,672) j,(tc(j,i),i=ii,ik)
                write(*,672) j,(tc(j,i),i=ii,ik)
              endif
            enddo
            write(lfnout,*) ' '
            write(*,*) ' '
          enddo
          deallocate(tc)
  
!     Diagonalize the NOCI matrix and print the energies and wave functions
          
          allocate (hev(nbase))
          allocate(work(10))
          lwrk=-1
          info=0
          call dsygv(1,'V','L',nbase,hbase,nbase,
     &         sbase,nbase,hev,work,lwrk,info)
          lwrk=int(work(1))
          if(lwrk.gt.lwork) then
            deallocate(work)
            lwork=lwrk
            allocate(work(lwork))
          endif
          call dsygv(1,'V','L',nbase,hbase,nbase,
     &         sbase,nbase,hev,work,lwork,info)
          
!     hbase now contains eigenvectors of diagonalized matrix
          
          write(*,677)
          write(lfnout,677)
 677      format(//,' NOCI energies and wave functions',/)

          nk=nbase/ncols
          if(mod(nbase,ncols).ne.0) nk=nk+1
          do k=1,nk
            ii=(k-1)*ncols+1
            il=min(nbase,k*ncols)
            
            write(*,'(a,12i20)')'    State:',(i,i=ii,il)
            write(*,678)'   Energy:    ', (hev(i),i=ii,il)
            write(*,*) ' '
            write(lfnout,'(a,12i20)')'     State:',(i,i=ii,il)
            write(lfnout,678)'    Energy:   ', (hev(i),i=ii,il)
            write(lfnout,*) ' '
            if(itest.eq.2) then
              write(lfntst,677)
              write(lfntst,'(a,12i20)')'     State:',(i,i=ii,il)
              write(lfntst,1678)'    Energy:   ', (hev(i),i=ii,il)
              write(lfntst,*) ' '
            endif
 678        format((a,12f20.10),//)
 1678       format((a,12f20.8),//)
            token="MEBF"
            do j=1,nbase
              write(*,679) token,j,(hbase(i,j),i=ii,il)
              write(lfnout,679) token,j,(hbase(i,j),i=ii,il)
 679          format(a4,1x,i5,4x,12f20.10)
              if(itest.eq.2) then
                write(lfntst,1679) token,j,(hbase(i,j),i=ii,il)
 1679           format(a4,1x,i5,4x,12f20.8)
              endif
              token="    "
            enddo
          enddo
        endif
      endif
      if(allocated(work)) deallocate(work)
      if(allocated(hev)) deallocate(hev)

      deallocate(t,v,ndxtv)
      deallocate(lab,ig,g)

      deallocate(idetb,nactb,inactb,ioccb,vecsb,civb)
      deallocate(ioccm,vecsm,civm)
      deallocate(idetm,inactm,nactm,nbasm,ncombv)
      deallocate(map2)

      deallocate(hbase,sbase,tbase,nsing)

      deallocate(lstdet,ndxdet)

      call timer_stop(4)
      call timer_stop(1)

      if(me.eq.master) then
       call timer_stop(99)
       call swatch(date,time)
       write(lfnday,702) date(1:8),time(1:8),timer_wall_total(99),
     &       '  :  End of Hamiltonian calculation'
       flush(lfnday)
       call timer_start(99)
      endif
       
      call gronor_timings(lfnout,lfnday)
       
      if(me.eq.master) deallocate(numrecs)

      close(unit=lfndbg,status='keep')
      if(me.eq.master) then
       close(unit=lfnout,status='keep')
       if(ipro.ge.3) then
        close(unit=lfnpro,status='keep')
       else
        close(unit=lfnpro,status='delete')
       endif
       close(unit=lfnday,status='keep')
       if(itest.eq.0) then
         close(unit=lfntst,status='delete')
       else
         close(unit=lfntst,status='keep')
       endif
      else
!       if(ipr.lt.5) then
!        close(unit=lfnout,status='delete')
!       else
!        close(unit=lfnout,status='keep')
!       endif
!       close(unit=lfnpro,status='delete')
      endif

      if(ifault.eq.0) then
        call mpi_finalize(ierr)
      else
        if(me.eq.master) call mpi_abort(MPI_COMM_WORLD,ierror,ierr)
      endif
      
      return
 994  write(lfnout,984) filsym(1:inp_strlen(fildbg))
      call errquit()
 995  write(lfnout,985) filsym(1:inp_strlen(filsym))
      call errquit()
 996  write(lfnout,986) filout(1:inp_strlen(filout))
      call errquit()
 997  write(lfnout,987) filvec(1:inp_strlen(filvec))
      call errquit()
 998  write(lfnout,988) filciv(1:inp_strlen(filciv))
      call errquit()
 999  write(lfnout,989) filinp(1:inp_strlen(filinp))
      call errquit()
 984  format('Unable to open debug file ',a)
 985  format('Unable to open symmetry file ',a)
 986  format('Unable to open output file ',a)
 987  format('Unable to open vects file ',a)
 988  format('Unable to open civec file ',a)
 989  format('Unable to open input file ',a)
      end
      
